

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>brutus &mdash; brutus 0.3.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="brutus 0.3.1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> brutus
          

          
            
            <img src="../_static/brutus.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installing brutus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../running.html">Running brutus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../acknowledge.html">Acknowledging brutus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/modules.html">Functions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">brutus</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>brutus</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for brutus</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> brutus: a set of Python modules to process datacubes from integral field spectrographs.\n</span>
<span class="sd"> Copyright (C) 2016,  F.P.A. Vogt</span>
<span class="sd"> </span>
<span class="sd"> -----------------------------------------------------------------------------------------</span>
<span class="sd"> </span>
<span class="sd"> This file contains the master brutus routines to fit the stellar continuum and the </span>
<span class="sd"> emission lines in an IFU data cube (i.e. MUSE). Most of these routines call sub-routines,</span>
<span class="sd"> after setting the scene/loading datasets/etc ...</span>
<span class="sd"> </span>
<span class="sd"> Any processing step MUST have a dediacted routine in this file call &#39;run_XXX&#39;, which can</span>
<span class="sd"> then refer to any existing/new brutus/Python module.</span>

<span class="sd"> Created April 2016, F.P.A. Vogt - frederic.vogt@alumni.anu.edu.au</span>
<span class="sd"> </span>
<span class="sd"> -----------------------------------------------------------------------------------------</span>
<span class="sd">  </span>
<span class="sd"> This program is free software: you can redistribute it and/or modify</span>
<span class="sd"> it under the terms of the GNU General Public License as published by</span>
<span class="sd"> the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd"> (at your option) any later version.</span>

<span class="sd"> This program is distributed in the hope that it will be useful,</span>
<span class="sd"> but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd"> GNU General Public License for more details.</span>

<span class="sd"> You should have received a copy of the GNU General Public License</span>
<span class="sd"> along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="sd"> </span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span> <span class="k">as</span> <span class="n">pyfits</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1"># Import brutus-specific tools</span>
<span class="kn">import</span> <span class="nn">brutus_tools</span>
<span class="kn">import</span> <span class="nn">brutus_cof</span>
<span class="kn">import</span> <span class="nn">brutus_elf</span>
<span class="kn">import</span> <span class="nn">brutus_plots</span>
<span class="kn">import</span> <span class="nn">brutus_red</span>
<span class="kn">from</span> <span class="nn">brutus_metadata</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">brutus_metadata</span> <span class="kn">import</span> <span class="n">__version__</span>

<span class="c1"># Import other important tools, but don&#39;t fail, in case the user doesn&#39;t need them.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">brutus_ppxf</span>
    <span class="kn">import</span> <span class="nn">ppxf_util</span> <span class="kn">as</span> <span class="nn">util</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Faild to load brutus_ppxf. Is ppxf installed ?&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">fit_kinematic_pa</span> <span class="kn">as</span> <span class="nn">fkp</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Faild to load fit_kinematic_pa. Is it installed ?&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyqz</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Faild to load pyqz. Is it installed ?&quot;</span><span class="p">)</span>

<span class="c1"># ---------------------------------------------------------------------------------------- </span>
  
<div class="viewcode-block" id="run_snr_maps"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_snr_maps">[docs]</a><span class="k">def</span> <span class="nf">run_snr_maps</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function computes the SNR maps for the continuum and Ha (or other line). </span>
<span class="sd">    It also creates a map of spaxels with any signal at all.</span>
<span class="sd">    The resulting maps are saved to a fits file with full header and WCS coordinates.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        do_plot: bool [default: True]</span>
<span class="sd">                 Whether to make a plot of the SNR maps or not.</span>
<span class="sd">        </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">                 </span>
<span class="sd">    :Notes:</span>
<span class="sd">        This function is a &quot;first guess&quot; of the SNR for latter use in the code. A more</span>
<span class="sd">        reliable measure of the SNR for the emission line should be computed after they</span>
<span class="sd">        have been fitted.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Computing the SNR maps.&#39;</span> 
    
    <span class="n">cont_range</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cont_range&#39;</span><span class="p">]</span>
    <span class="n">line_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ref_dv_line&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">200.</span><span class="o">/</span><span class="n">c</span><span class="p">),</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ref_dv_line&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">200.</span><span class="o">/</span><span class="n">c</span><span class="p">)]</span>
    
    <span class="c1"># Import the fits file </span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Build the wavelength array - REST frame !</span>
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    <span class="n">lams</span> <span class="o">/=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
    
    <span class="c1"># Continuum: median intensity level across range vs std across range</span>
    <span class="c1"># I get some warnings for all-nans slices ... damn ... For clarity in the prompt, </span>
    <span class="c1"># let&#39;s catch them and ignore them just this once, if the user is ok with it.</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;warnings&#39;</span><span class="p">],</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="c1"># The signal</span>
        <span class="n">cont_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data</span><span class="p">[(</span><span class="n">lams</span><span class="o">&gt;=</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">lams</span><span class="o">&lt;=</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),:,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
        <span class="c1"># The noise</span>
        <span class="n">cont_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data</span><span class="p">[(</span><span class="n">lams</span><span class="o">&gt;=</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">lams</span><span class="o">&lt;=</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),:,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    
    <span class="n">cont_snr</span> <span class="o">=</span> <span class="n">cont_s</span><span class="o">/</span><span class="n">cont_n</span>
    <span class="c1"># Also make sure this is always &gt; 0</span>
    <span class="n">cont_snr</span><span class="p">[</span><span class="n">cont_snr</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># I also want to compute the SNR map for the strongest emission line in there.</span>
    <span class="c1"># This line is defined via the &#39;ref_dv_line&#39; in params (i.e. it is the same line used </span>
    <span class="c1"># for initial v guess for the emission line fitting).</span>
    <span class="c1"># I get some warnings for all-nans slices ... damn ... For clarity in the prompt, </span>
    <span class="c1"># let&#39;s catch them and ignore them just this once, if the user is ok with it.</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;warnings&#39;</span><span class="p">],</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="n">line_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span> <span class="p">(</span><span class="n">lams</span><span class="o">&gt;=</span><span class="n">line_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">lams</span><span class="o">&lt;=</span><span class="n">line_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># For the line, I measure the line &quot;peak&quot; above the noise. This is NOT ideal, but it</span>
    <span class="c1"># &quot;only&quot; needs to ignore&quot; pixels with no signals to save time during the fitting. </span>
    <span class="n">line_snr</span> <span class="o">=</span> <span class="n">line_s</span><span class="o">/</span><span class="n">cont_n</span>
    <span class="c1"># Make sure this is always &gt;0</span>
    <span class="n">line_snr</span><span class="p">[</span><span class="n">line_snr</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># And create a map with just spaxels that have any data (i.e. have been observed).</span>
    <span class="n">anything</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:])</span>
    <span class="n">anything</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
    <span class="c1"># Very well, now let&#39;s create a fits file to save this as required.</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">cont_snr</span><span class="p">)</span>
    <span class="n">hdu2</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">line_snr</span><span class="p">)</span>
    <span class="n">hdu3</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">anything</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="p">[</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">,</span><span class="n">hdu3</span><span class="p">]:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="c1"># For reference, also include the line/region this maps are based on</span>
    <span class="n">hdu1</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BRRANG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">cont_range</span><span class="p">),</span> <span class="s1">&#39;spectral range used for continuum SNR&#39;</span><span class="p">)</span>
    <span class="n">hdu2</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BRRANG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">line_range</span><span class="p">),</span> <span class="s1">&#39;spectral range used for line SNR&#39;</span><span class="p">)</span> 
        
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">,</span><span class="n">hdu3</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_snr.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># And add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;snr_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_snr.fits&#39;</span>
                
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
        <span class="c1"># Alright, let&#39;s take out the big guns ...            </span>
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> 
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                                         <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_cont_snr.pdf&#39;</span><span class="p">),</span>
                            <span class="n">contours</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                            <span class="n">cbticks</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span> 
                            <span class="n">cblabel</span> <span class="o">=</span> <span class="s1">r&#39;Continuum SNR </span><span class="si">%.2f</span><span class="s1">\AA\ - </span><span class="si">%.2f</span><span class="s1">\AA&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                            <span class="p">)</span>  
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> 
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                                         <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_line_snr.pdf&#39;</span><span class="p">),</span>
                            <span class="n">contours</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                            <span class="n">cbticks</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span>
                            <span class="n">cblabel</span> <span class="o">=</span> <span class="s1">r&#39;</span><span class="si">%.2f</span><span class="s1">\AA\ emission line SNR&#39;</span> <span class="o">%</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ref_dv_line&#39;</span><span class="p">],</span>
                            <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                            <span class="p">)</span>    
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> 
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                                         <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_signal.pdf&#39;</span><span class="p">),</span>
                            <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cbticks</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">cmap</span> <span class="o">=</span><span class="s1">&#39;alligator&#39;</span><span class="p">,</span>
                            <span class="n">cblabel</span> <span class="o">=</span> <span class="s1">r&#39;Spaxels with data&#39;</span><span class="p">,</span>
                            <span class="n">scalebar</span> <span class="o">=</span> <span class="bp">None</span>
                            <span class="p">)</span>               
                         
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ---------------------------------------------------------------------------------------- </span>
  
<div class="viewcode-block" id="run_gal_dered"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_gal_dered">[docs]</a><span class="k">def</span> <span class="nf">run_gal_dered</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Corrects for Galactic extinction, given the Ab and Av extinction.</span>
<span class="sd">    </span>
<span class="sd">    This function erives the Alambda value for any wavelength, and corrects the data to</span>
<span class="sd">    correct for our &quot;local&quot; extinction. Intended for extragalactic sources.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        do_plot: bool [default: True]</span>
<span class="sd">                 Whether to make a plot of the Alambda correction applied or not.</span>
<span class="sd">        </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">                 </span>
<span class="sd">    :Notes:</span>
<span class="sd">        To reproduce the approach from NED, use the Ab and Av value for you object from </span>
<span class="sd">        there, and set curve=&#39;f99&#39;, rv=3.1.   </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Correcting for Galactic extinction.&#39;</span> 
    
    <span class="c1"># Import the raw data </span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Build the wavelength array</span>
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    
    <span class="c1"># Compute Alambda</span>
    <span class="n">alams</span> <span class="o">=</span> <span class="n">brutus_red</span><span class="o">.</span><span class="n">alam</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;Ab&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Av&#39;</span><span class="p">],</span> <span class="n">curve</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;gal_curve&#39;</span><span class="p">],</span>
                           <span class="n">rv</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;gal_rv&#39;</span><span class="p">])</span>
    
    <span class="c1"># Compute the flux correction factor</span>
    <span class="n">etau</span> <span class="o">=</span> <span class="n">brutus_red</span><span class="o">.</span><span class="n">galactic_red</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Ab&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Av&#39;</span><span class="p">],</span> 
                                  <span class="n">curve</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;gal_curve&#39;</span><span class="p">],</span>
                                  <span class="n">rv</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;gal_rv&#39;</span><span class="p">])</span>
    
    <span class="c1"># Correct the data and the propagate the errors</span>
    <span class="n">data</span> <span class="o">*=</span> <span class="n">etau</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">error</span> <span class="o">*=</span> <span class="p">(</span><span class="n">etau</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="c1"># Save the datacubes</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">hdu2</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="p">[</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">]:</span>
        <span class="c1"># Make sure the WCS coordinates are included as well</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_lams</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
        <span class="c1"># Add the line reference wavelength for future references</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_AB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Ab&#39;</span><span class="p">],</span> <span class="s1">&#39;Extinction in B&#39;</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_AV&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Av&#39;</span><span class="p">],</span> <span class="s1">&#39;Extinction in V&#39;</span><span class="p">)</span>
            
            
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                              <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_galdered.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_galdered.fits&#39;</span>
    
    <span class="c1"># Do I want to save a plot ?</span>
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
        <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span>
                            <span class="s1">&#39;_gal_Alambda_corr.pdf&#39;</span><span class="p">)</span>
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_galred_plot</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span><span class="n">alams</span><span class="p">,</span><span class="n">etau</span><span class="p">,</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Ab&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;Av&#39;</span><span class="p">],</span> <span class="n">ofn</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fn_list</span></div>
    
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_fit_continuum"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_fit_continuum">[docs]</a><span class="k">def</span> <span class="nf">run_fit_continuum</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start_row</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">end_row</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> 
                      <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lowess&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function fits the continuum in the datacube, either using ppxf (if SNR is decent)</span>
<span class="sd">    or using a simple polynomial value. It is designed to use multiprocessing to speed</span>
<span class="sd">    things up on good computers. It deals with the data columns-per-columns, and </span>
<span class="sd">    can be restarted mid-course, in case of a crash. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># For the bad continuum: run a LOWESS filter from statsmodel.nonparametric</span>
    <span class="c1">#sm.nonparametric.smoothers_lowess.lowess(spec,lams,frac=0.05, it=5)</span>
    <span class="c1"># For the good fits, run ppxf</span>
    
    <span class="c1"># Rather than launch it all at once, let&#39;s be smart in case of problems. I&#39;ll run</span>
	<span class="c1"># the fits row-by-row with multiprocessing (hence up to 300cpus can help!), and save</span>
	<span class="c1"># between each row.</span>
	
	<span class="c1"># First, load the datacube to be fitted. Use the galactic deredened one, if it exists.</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Build the wavelength array</span>
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    
    <span class="c1"># I also need to load the SNR cube for the spaxel selection</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;snr_cube&#39;</span><span class="p">]))</span>
    <span class="n">snr_cont</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Get some info about the cube</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">start_row</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">end_row</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
	    <span class="n">end_row</span> <span class="o">=</span> <span class="n">nrows</span><span class="o">-</span><span class="mi">1</span>
	
	<span class="c1"># Ok, what do I want to do ?</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lowess&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="k">print</span> <span class="s1">&#39;-&gt; Starting the continuum fitting using the LOWESS approach.&#39;</span>
            
        <span class="n">fit_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">brutus_cof</span><span class="o">.</span><span class="n">lowess_fit</span><span class="p">,</span> <span class="n">lams</span><span class="o">=</span><span class="n">lams</span><span class="p">,</span> 
                           <span class="n">frac</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;lowess_frac&#39;</span><span class="p">],</span> <span class="n">it</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;lowess_it&#39;</span><span class="p">])</span>
        <span class="c1"># Note here the clever use of the partial function, that turns the lowess_fit</span>
        <span class="c1"># function from something that takes 4 arguments into something that only takes 1</span>
        <span class="c1"># argument ... thus perfect for the upcoming &quot;map&quot; functions !</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="k">print</span> <span class="s1">&#39;-&gt; Starting the continuum fitting using PPXF.&#39;</span> 
        	
        <span class="c1"># I need to do some special preparation for &#39;ppxf&#39;. Namely, log-rebin the </span>
        <span class="c1"># templates. I could do that for each fit, bit it would cost me time. At the price </span>
        <span class="c1"># of a larger code here, do it only once, and save &quot;tons&quot; of time (~0.5s per fit).</span>
        <span class="c1"># The code below is based on the examples provided by M. Cappellari within ppxf </span>
        <span class="c1"># istelf (ppxf_kinematics_example_sauron.py &amp; ppxf_population_example_sdss.py), </span>
        <span class="c1"># but has been modified to account a wavelength dependant spectral resolution of </span>
        <span class="c1"># the data. And avoid doing the same thing multiple times via multiprocessing. </span>
        
        <span class="c1"># The full spectral range</span>
        <span class="n">lam_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lams</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lams</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        
        <span class="c1"># De-redshift it using the user&#39;s best guess</span>
        <span class="c1"># Here&#39;s the original text from M. Cappellari:</span>
        <span class="c1">#</span>
        <span class="c1"># &lt;&lt; If the galaxy is at a significant redshift (z &gt; 0.03), one would need to </span>
        <span class="c1"># apply a large velocity shift in PPXF to match the template to the galaxy </span>
        <span class="c1"># spectrum. This would require a large initial value for the velocity (V&gt;1e4 km/s)</span>
        <span class="c1"># in the input parameter START = [V,sig]. This can cause PPXF to stop!</span>
        <span class="c1"># The solution consists of bringing the galaxy spectrum roughly to the</span>
        <span class="c1"># rest-frame wavelength, before calling PPXF. In practice there is no</span>
        <span class="c1"># need to modify the spectrum before the usual LOG_REBIN, given that a</span>
        <span class="c1"># red shift corresponds to a linear shift of the log-rebinned spectrum.</span>
        <span class="c1"># One just needs to compute the wavelength range in the rest-frame</span>
        <span class="c1"># and adjust the instrumental resolution of the galaxy observations. &gt;&gt;</span>
        <span class="n">lams0</span> <span class="o">=</span> <span class="n">lams</span><span class="o">/</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lam_range0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lams0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lams0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        
        <span class="c1"># We can only fit the spectra where they overlap with the spectral library.</span>
        <span class="c1"># Get one of the templates, figure out its range, and derive the fit limits.</span>
        <span class="n">sl_fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sl_models</span><span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_sl_name&#39;</span><span class="p">]][</span><span class="s1">&#39;sl_loc&#39;</span><span class="p">],</span><span class="s1">&#39;*&#39;</span><span class="p">))</span>
        <span class="n">hdu_sl</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">sl_fns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">header_sl</span> <span class="o">=</span> <span class="n">hdu_sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
        <span class="n">hdu_sl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="n">lams_sl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header_sl</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">header_sl</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span> <span class="o">+</span> \
                                                                       <span class="n">header_sl</span><span class="p">[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span>
        <span class="n">lam_range_sl</span> <span class="o">=</span> <span class="p">[</span><span class="n">lams_sl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lams_sl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="c1"># What are my fit limits, then ?</span>
        <span class="n">fit_lims</span> <span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">lam_range0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">lam_range_sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> 
                   <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">lam_range0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">lam_range_sl</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>  
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">lams0</span> <span class="o">&gt;</span> <span class="n">fit_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">lams0</span> <span class="o">&lt;</span> <span class="n">fit_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lams0c</span> <span class="o">=</span> <span class="n">lams0</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">lam_range0c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lams0c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lams0c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        
        <span class="c1"># Soon, I will be log-rebining the spectra. What are the new bins going to be ?</span>
        <span class="n">log_lams0c</span><span class="p">,</span> <span class="n">emptyspec</span><span class="p">,</span> <span class="n">velscale</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">log_rebin</span><span class="p">(</span><span class="n">lams0c</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lams0c</span><span class="p">),</span> 
                                                     <span class="n">sampling</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_sampling&#39;</span><span class="p">])</span>
        
        <span class="c1"># Deal with the template spectra: disperse them according to the instrument, and</span>
        <span class="c1"># log-rebin them</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Preparing the templates ... &#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            
        <span class="n">templates</span><span class="p">,</span> <span class="n">lam_range_temp</span><span class="p">,</span> <span class="n">logAge_grid</span><span class="p">,</span> <span class="n">metal_grid</span><span class="p">,</span> <span class="n">log_lams_temp</span> <span class="o">=</span> \
        <span class="n">brutus_ppxf</span><span class="o">.</span><span class="n">setup_spectral_library</span><span class="p">(</span><span class="n">velscale</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;inst&#39;</span><span class="p">],</span> 
                                          <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_sl_name&#39;</span><span class="p">],</span> <span class="n">fit_lims</span><span class="p">,</span> 
                                          <span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>   
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;done.&#39;</span><span class="p">)</span>
            <span class="k">print</span> <span class="s1">&#39; &#39;</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>                                      
                                          
                                          
        <span class="c1"># For the fit reconstruction later on, save the various wavelength ranges, etc ...</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ppxf_lams.pkl&#39;</span><span class="p">)</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">([</span><span class="n">lams</span><span class="p">,</span><span class="n">lams0</span><span class="p">,</span><span class="n">lams0c</span><span class="p">,</span><span class="n">log_lams0c</span><span class="p">],</span><span class="nb">file</span><span class="p">)</span>
        <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># And add the generic pickle filename to the dictionary of filenames</span>
        <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_lams&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ppxf_lams.pkl&#39;</span>              
                                          
        <span class="c1"># From M. Cappellari:</span>
        <span class="c1"># &lt;&lt; The galaxy and the template spectra do not have the same starting wavelength.</span>
        <span class="c1"># For this reason an extra velocity shift DV has to be applied to the template</span>
        <span class="c1"># to fit the galaxy spectrum. We remove this artificial shift by using the</span>
        <span class="c1"># keyword VSYST in the call to PPXF below, so that all velocities are</span>
        <span class="c1"># measured with respect to DV.&gt;&gt;</span>
        <span class="c1">#</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lam_range_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">lam_range0c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        
        <span class="c1"># Initial estimate of the galaxy velocity in km/s:        </span>
        <span class="n">vel</span> <span class="o">=</span> <span class="mf">0.</span>   <span class="c1"># It&#39;s been de-redshifted (using user&#39;s guess)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">vel</span><span class="p">,</span> <span class="mf">100.</span><span class="p">]</span>  <span class="c1"># (km/s), starting guess for [V,sigma]</span>
        
        <span class="c1"># Now create a list of &quot;good pixels&quot;, i.e. mask emission lines and stuff.</span>
        <span class="c1"># List is the default one from ppxf.</span>
        <span class="n">goodpixels</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">determine_goodpixels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">log_lams0c</span><span class="p">),</span> <span class="n">lam_range_temp</span><span class="p">,</span> <span class="n">vel</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># See the pPXF documentation for the keyword REGUL, and an explanation of the </span>
        <span class="c1"># following two lines</span>
        <span class="n">templates</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">templates</span><span class="p">)</span> <span class="c1"># Normalizes templates by a scalar</span>
        <span class="n">regul_err</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_regul_err&#39;</span><span class="p">]</span>  <span class="c1"># Desired regularization error</span>
        
        <span class="n">fit_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">brutus_ppxf</span><span class="o">.</span><span class="n">ppxf_population</span><span class="p">,</span> <span class="n">templates</span><span class="o">=</span><span class="n">templates</span><span class="p">,</span> 
                           <span class="n">velscale</span><span class="o">=</span><span class="n">velscale</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">goodpixels</span><span class="o">=</span><span class="n">goodpixels</span><span class="p">,</span> 
                           <span class="n">plot</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_moments&#39;</span><span class="p">],</span> 
                           <span class="n">degree</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_degree&#39;</span><span class="p">],</span> <span class="n">vsyst</span><span class="o">=</span><span class="n">dv</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                           <span class="n">mdegree</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_mdegree&#39;</span><span class="p">],</span> <span class="n">regul</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">regul_err</span><span class="p">)</span>    

    <span class="c1"># Very well, let&#39;s start the loop on rows. If the code crashes/is interrupted, you&#39;ll</span>
    <span class="c1"># loose the current row. Just live with it.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_row</span><span class="p">,</span><span class="n">end_row</span><span class="p">,</span> <span class="n">end_row</span><span class="o">-</span><span class="n">start_row</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>   
	
		<span class="c1"># Alright, now deal with the spaxels outside the user-chosen SNR range.</span>
		<span class="c1"># Replace them with nan&#39;s</span>
        <span class="n">good_spaxels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_snr_min&#39;</span><span class="p">]:</span>
            <span class="n">good_spaxels</span><span class="p">[</span><span class="n">snr_cont</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">params</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_snr_min&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_snr_max&#39;</span><span class="p">]:</span>
            <span class="n">good_spaxels</span><span class="p">[</span><span class="n">snr_cont</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">params</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_snr_max&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		
		<span class="c1"># Build a list of spectra to be fitted</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">]</span> <span class="o">*</span> <span class="n">good_spaxels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">])]</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">error</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">]</span> <span class="o">*</span> <span class="n">good_spaxels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">])]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Log-rebin spectra in row %2.i ...            &#39;</span><span class="o">%</span><span class="n">row</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                
            <span class="c1"># I need to do some special preparation for &#39;ppxf&#39;. Namely, log-rebin the </span>
            <span class="c1"># spectra, and crop them to an appropriate wavelength after de-redshifting. </span>
            <span class="c1"># Let&#39;s get started. </span>
            <span class="c1"># To save time, only log-rebin spectra that are not all nans</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">brutus_tools</span><span class="o">.</span><span class="n">log_rebin</span><span class="p">(</span><span class="n">lam_range0c</span><span class="p">,</span> <span class="n">this_spec</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                                     <span class="n">sampling</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_sampling&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> 
                                     <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">this_spec</span><span class="p">)))</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
                                     <span class="k">for</span> <span class="n">this_spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">]</span>                      
            <span class="c1"># Also take care of the error</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">brutus_tools</span><span class="o">.</span><span class="n">log_rebin</span><span class="p">(</span><span class="n">lam_range0c</span><span class="p">,</span> <span class="n">this_err</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> 
                                     <span class="n">sampling</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_sampling&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
                                     <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">this_err</span><span class="p">)))</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  
                                     <span class="k">for</span> <span class="n">this_err</span> <span class="ow">in</span> <span class="n">errs</span><span class="p">]</span>                                                                 
                                                                            
            <span class="c1"># Combine both spectra and errors, to feed only 1 element to fit_func</span>
            <span class="c1"># Turn the error into a std to feed ppxf</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">specs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">])]</span>
        
		<span class="c1"># Set up the multiprocessing pool of workers</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">]:</span>
            <span class="c1"># Did the user specify a number of processes to use ?</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>
                <span class="n">nproc</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">]</span>
                
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Ok, just use them all ...</span>
                <span class="n">nproc</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
                
			<span class="c1"># Limiting the maximum number of cpus for ppxf, to avoid memory errors... </span>
            <span class="k">if</span> <span class="n">nproc</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>
                <span class="n">nproc</span> <span class="o">=</span> <span class="mi">8</span>
                
            <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span> <span class="o">=</span> <span class="n">nproc</span><span class="p">,</span> 
			                            <span class="n">initializer</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">init_worker</span><span class="p">())</span>    
			
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Fitting spectra in row %2.i, </span><span class="si">%i</span><span class="s1"> at a time ...&#39;</span> <span class="o">%</span> 
                                 <span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">nproc</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
			
            <span class="c1"># Launch the fitting ! Make sure to deal with KeyBoard Interrupt properly</span>
			<span class="c1"># Only a problem for multiprocessing. For the rest of the code, whatever.</span>
            <span class="k">try</span><span class="p">:</span>   
                <span class="n">conts</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fit_func</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39; interrupted !&#39;</span>
                <span class="c1"># Still close and join properly</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Multiprocessing continuum fitting interrupted at row </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span> <span class="n">row</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># If all is fine</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  
              
              
        <span class="k">else</span><span class="p">:</span> <span class="c1"># just do things 1-by-1</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Fitting spectra in row %2.i, one at a time ...&#39;</span> <span class="o">%</span> 
                                 <span class="n">row</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                                
            <span class="n">conts</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">fit_func</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
	    
	    <span class="c1"># Here, I need to save these results. Pickle could be fast and temporary,</span>
	    <span class="c1"># Until I then re-build the entire cube later on ? Also allow for better</span>
	    <span class="c1"># row-by-row flexibility.</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_row_&#39;</span><span class="o">+</span>
                          <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">conts</span><span class="p">,</span><span class="nb">file</span><span class="p">)</span>
        <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
    <span class="c1"># And add the generic pickle filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_pickle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_row_&#39;</span>
   	     
    <span class="k">print</span> <span class="s1">&#39; done !&#39;</span>
    
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_make_continuum_cube"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_make_continuum_cube">[docs]</a><span class="k">def</span> <span class="nf">run_make_continuum_cube</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lowess&#39;</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to construct a &quot;usable and decent&quot; datacube out of the</span>
<span class="sd">    mess generated by the continuum fitting function, i.e. out of the many pickle </span>
<span class="sd">    files generated.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Constructing the datacube for the continuum fitting (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="n">method</span>
       
    <span class="c1"># First, load the original datacube. I need to know how much stuff was fitted.</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
    
    <span class="n">cont_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># In the case of ppxf, also extract the stellar moments.</span>
    <span class="c1"># Not the most trustworthy, but interesting nonetheless.</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_moments&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">ppxf_sol_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_moments&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span>
                                                        <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># For ppxf, also create a spectrum with the de-logged rebin original spectra. Useful </span>
    <span class="c1"># to characterize the error associated with log-bin-delog-rebin process employed here.</span>
    <span class="n">delog_raw_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                                                        
    <span class="c1"># Loop through the rows, and extract the results. </span>
    <span class="c1"># Try to loop through everything - in case this step was run in chunks.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nrows</span><span class="p">):</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">nrows</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Building cube [</span><span class="si">%5.1f%s</span><span class="s1">]&#39;</span> <span class="o">%</span> 
                         <span class="p">(</span><span class="n">progress</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">fn_list</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_pickle&#39;</span><span class="p">]</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="c1"># Very well, I have some fit here. Let&#39;s get them back</span>
            <span class="n">myfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">conts</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">myfile</span><span class="p">)</span>  
            <span class="n">myfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
        
            <span class="c1"># Mind the shape</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;lowess&#39;</span><span class="p">:</span>
                <span class="c1"># I directly saved the continuum as an array just get it out.</span>
                <span class="n">cont_cube</span><span class="p">[:,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conts</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> 
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span><span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>
                <span class="c1"># Alright, in this case, the pickle file contains the output from ppxf</span>
            
                <span class="c1"># Extract the various wavelength ranges, etc ...</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_lams&#39;</span><span class="p">])</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="n">lams</span><span class="p">,</span><span class="n">lams0</span><span class="p">,</span><span class="n">lams0c</span><span class="p">,</span><span class="n">log_lams0c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                
                <span class="c1"># The fit outputs are all on the log_lams0c grid, and I want them back on</span>
                <span class="c1"># lams.  </span>
                <span class="c1"># First, extract the bestfit spectra. </span>
                <span class="c1"># For test purposes, also extract the galaxy spectra with pp.galaxy</span>
                <span class="n">bestfits</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">pp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">conts</span><span class="p">]</span>
                <span class="n">galaxys</span> <span class="o">=</span> <span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">pp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">conts</span><span class="p">]</span>
                
                <span class="c1"># And the stellar moments</span>
                <span class="n">ppxf_sol_map</span><span class="p">[:,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">pp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="k">else</span> 
                                                  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_moments&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
                                                  <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">conts</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                                                  
                <span class="c1"># Now, I need storage that spans the original data range</span>
                <span class="n">full_bestfits</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lams0</span><span class="p">)</span> <span class="k">for</span> <span class="n">this_spec</span> <span class="ow">in</span> <span class="n">bestfits</span><span class="p">]</span>
                <span class="n">full_galaxys</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lams0</span><span class="p">)</span> <span class="k">for</span> <span class="n">this_spec</span> <span class="ow">in</span> <span class="n">galaxys</span><span class="p">]</span>
                
                <span class="c1"># Now, I want to delog-rebin the spectra back to the original grid</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">cube</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">bestfits</span><span class="p">,</span> <span class="n">galaxys</span><span class="p">]):</span>
                    <span class="n">cube</span> <span class="o">=</span> <span class="p">[</span><span class="n">brutus_tools</span><span class="o">.</span><span class="n">delog_rebin</span><span class="p">(</span><span class="n">log_lams0c</span><span class="p">,</span> <span class="n">this_spec</span><span class="p">,</span> <span class="n">lams0c</span><span class="p">,</span> 
                                                    <span class="n">sampling</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;ppxf_sampling&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span> 
                            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">this_spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">this_spec</span> <span class="ow">in</span> <span class="n">cube</span><span class="p">]</span>
                            
                    <span class="c1"># Now, I want to un-crop this, by adding nans elsewhere. Make a loop, </span>
                    <span class="c1"># but there&#39;s probably a more Pythonic way of doing it. </span>
                    <span class="c1"># TODO: try again when my brain won&#39;t be that fried ...</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">lams0</span> <span class="o">&gt;=</span><span class="n">lams0c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">lams0</span><span class="o">&lt;=</span><span class="n">lams0c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
                    <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">fit</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cube</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">fit</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                            <span class="p">[</span><span class="n">full_bestfits</span><span class="p">,</span><span class="n">full_galaxys</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">f</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit</span>
                
                    <span class="c1"># And finally, I need to de-redshift that spectra. No need to touch </span>
                    <span class="c1"># the spectra because I did not touch it before.</span>
                
                    <span class="c1"># Ready to save the continuum cube</span>
                    <span class="p">[</span><span class="n">cont_cube</span><span class="p">,</span><span class="n">delog_raw_cube</span><span class="p">][</span><span class="n">k</span><span class="p">][:,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> \
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">full_bestfits</span><span class="p">,</span> <span class="n">full_galaxys</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>                                     
        <span class="c1"># For consistency with the rest of the code, add the guess redshift to the velocity. </span>
        <span class="n">ppxf_sol_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">+=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">c</span>
                                     
    <span class="c1"># Very well, now let&#39;s create a fits file to save this as required.</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">cont_cube</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_lams</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># And add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;.fits&#39;</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span><span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>
    
        <span class="c1"># Also add the delog-rebin raw cube, and the moments maps</span>
        <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">delog_raw_cube</span><span class="p">)</span>
        <span class="c1"># Make sure the WCS coordinates are included as well</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_lams</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                              <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_delog_raw.fits&#39;</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
        <span class="c1"># And add the filename to the dictionary of filenames</span>
        <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_delog_raw_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span>\
                                           <span class="s1">&#39;_delog_raw.fits&#39;</span>                     
        <span class="c1"># ---                                   </span>
        <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">ppxf_sol_map</span><span class="p">)</span>
        <span class="c1"># Make sure the WCS coordinates are included as well</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                              <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="s1">&#39;_sol_map.fits&#39;</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
        <span class="c1"># And add the filename to the dictionary of filenames</span>
        <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_sol_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">method</span><span class="o">+</span>\
                                           <span class="s1">&#39;_sol_map.fits&#39;</span>                                  
                                           
    <span class="k">print</span> <span class="s1">&#39; &#39;</span>
    
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_plot_ppxf_sol"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_plot_ppxf_sol">[docs]</a><span class="k">def</span> <span class="nf">run_plot_ppxf_sol</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vrange</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sigrange</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; Creates some plots for the stellar kinematics parameters derived via ppxf.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        vrange: list of int [default: None]</span>
<span class="sd">                If set, the range of the colorbar for the velocity plot.</span>
<span class="sd">        sigrangre: list of int [default: None]        </span>
<span class="sd">                If set, the range of the colorbar for the velocity dispersion plot.</span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames.</span>
<span class="sd">    &#39;&#39;&#39;</span>    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Making some nifty plots to visualize the output of ppxf.&#39;</span>
     
    <span class="c1"># Open the file with the ppxf parameters   </span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_sol_map&#39;</span><span class="p">])</span>
    
    <span class="c1"># Open the file</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Create a temporary FITS file</span>
    <span class="n">fn_tmp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_tmp.fits&#39;</span><span class="p">)</span>

    <span class="c1"># Because of the way aplpy works, I need to stored each &quot;image&quot; in its own fits</span>
    <span class="c1"># file. I don&#39;t want to keep them, so let&#39;s just use a temporary one, get the plot</span>
    <span class="c1"># done, and remove it. Not ideal, but who cares ?</span>
        
    <span class="c1"># Make single pretty plots for v, sigma, h3,h4, h5, h6 if they exist  </span>
    <span class="nb">type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;h3&#39;</span><span class="p">,</span> <span class="s1">&#39;h4&#39;</span><span class="p">,</span> <span class="s1">&#39;h5&#39;</span><span class="p">,</span> <span class="s1">&#39;h6&#39;</span> <span class="p">]</span>                                     
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Create a dedicated HDU</span>
        <span class="n">tmphdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="c1"># Add the WCS information</span>
        <span class="n">tmphdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">tmphdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="n">tmphdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            
        <span class="c1"># Now plot it </span>
        <span class="n">this_ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ppxf_&#39;</span><span class="o">+</span>
                                                        <span class="nb">type</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">)</span> 
            
        <span class="c1"># For the velocity fields, set the vmin and vmax</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vrange</span><span class="p">:</span>
            <span class="n">my_vmin</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">my_vmax</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">my_cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span>
            <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="n">my_label</span> <span class="o">=</span> <span class="s1">r&#39;$v$ [km s$^{-1}$]&#39;</span>
            <span class="n">my_cbticks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">sigrange</span><span class="p">:</span>
            <span class="n">my_vmin</span> <span class="o">=</span> <span class="n">sigrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">my_vmax</span> <span class="o">=</span> <span class="n">sigrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">my_cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span>
            <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="n">my_label</span> <span class="o">=</span> <span class="s1">r&#39;$\sigma_{tot}$ [km s$^{-1}$]&#39;</span>
            <span class="n">my_cbticks</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">my_vmin</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">my_vmax</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">my_cmap</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="n">my_label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">my_cbticks</span> <span class="o">=</span> <span class="bp">None</span>
                                                            
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ofn</span><span class="o">=</span><span class="n">this_ofn</span><span class="p">,</span> <span class="n">contours</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                                    <span class="n">vmin</span><span class="o">=</span><span class="n">my_vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">my_vmax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">my_cmap</span><span class="p">,</span>
                                    <span class="n">stretch</span> <span class="o">=</span> <span class="n">my_stretch</span><span class="p">,</span> <span class="n">cblabel</span><span class="o">=</span><span class="n">my_label</span><span class="p">,</span> 
                                    <span class="n">cbticks</span> <span class="o">=</span> <span class="n">my_cbticks</span><span class="p">,</span>
                                    <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                                    <span class="p">)</span>                                   
    
    <span class="c1"># Delete the temporary fits file</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fn_list</span>    </div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_build_continuum_mix"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_build_continuum_mix">[docs]</a><span class="k">def</span> <span class="nf">run_build_continuum_mix</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; Construct the mixed continuum cube, following the user&#39;s wishes.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames.</span>
<span class="sd">    &#39;&#39;&#39;</span>   
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Constructing the mixed continuum cube.&#39;</span>
    
    <span class="c1"># First, the raw datacube. Use the galactic deredened one if it exists.</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># I also need the continuum cubes</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;lowess_cube&#39;</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;lowess_cube&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">cont_lowess</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_cube&#39;</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_cube&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">cont_ppxf</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># I also need to load the SNR cube for the spaxel selection</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;snr_cube&#39;</span><span class="p">]))</span>
    <span class="n">snr_cont</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>                               
    <span class="n">snr_elines</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>        
    
     
    <span class="c1"># Here, I don&#39;t use nan&#39;s. Should I ? </span>
    <span class="n">cont_mix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> 
    
    <span class="c1"># Very well, now, combine the different continua</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;which_cont_sub&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="k">print</span> <span class="s1">&#39;   SNR </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;which_cont_sub&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                
        <span class="n">llim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">ulim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">snr_cont</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
        	<span class="n">ulim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
         
        <span class="c1"># Assume the continuum subtraction is error free (either lowess or models).</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;which_cont_sub&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lowess&#39;</span><span class="p">:</span>
            <span class="n">cont_mix</span><span class="p">[:,(</span><span class="n">snr_cont</span><span class="o">&gt;=</span><span class="n">llim</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">snr_cont</span><span class="o">&lt;</span><span class="n">ulim</span><span class="p">)]</span> <span class="o">=</span> \
                     <span class="n">cont_lowess</span><span class="p">[:,(</span><span class="n">snr_cont</span><span class="o">&gt;=</span><span class="n">llim</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">snr_cont</span><span class="o">&lt;</span><span class="n">ulim</span><span class="p">)]</span> 
        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;which_cont_sub&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">:</span>
            <span class="n">cont_mix</span><span class="p">[:,(</span><span class="n">snr_cont</span><span class="o">&gt;=</span><span class="n">llim</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">snr_cont</span><span class="o">&lt;</span><span class="n">ulim</span><span class="p">)]</span> <span class="o">=</span> \
                     <span class="n">cont_ppxf</span><span class="p">[:,(</span><span class="n">snr_cont</span><span class="o">&gt;=</span><span class="n">llim</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">snr_cont</span><span class="o">&lt;</span><span class="n">ulim</span><span class="p">)]</span>   
    
    <span class="c1"># Save the cube</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">cont_mix</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_lams</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_mixed_continuum_cube.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Add the generic filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_mixed_continuum_cube.fits&#39;</span>
    
    <span class="k">return</span> <span class="n">fn_list</span>  </div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_fit_elines"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_fit_elines">[docs]</a><span class="k">def</span> <span class="nf">run_fit_elines</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start_row</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">end_row</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> 
                   <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function fits the emission lines in the datacube, after subtracting the continuum</span>
<span class="sd">    derived using LOWESSS or PPXF. It is designed to use multiprocessing to speed</span>
<span class="sd">    things up on good computers. It deals with the data columns-per-columns, and </span>
<span class="sd">    can be restarted mid-course, in case of a crash. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Starting the emission line fitting for %2.i line(s).&#39;</span> <span class="o">%</span> <span class="n">nlines</span> 
    
    <span class="c1"># Rather than launch it all at once, let&#39;s be smart in case of problems. I&#39;ll run</span>
	<span class="c1"># the fits row-by-row with multiprocessing (hence up to 300cpus can help!), and save</span>
	<span class="c1"># between each row.</span>
	
	<span class="c1"># First, load the datacube to be fitted. Use the galactic deredened one if it exists.</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Build the wavelength array</span>
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    <span class="c1"># Calculate the outer bin edges for the spectrum</span>
    <span class="n">be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lams</span><span class="o">-</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">lams</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    
    <span class="c1"># I also need to load the SNR cube for the spaxel selection</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                                   <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;snr_cube&#39;</span><span class="p">]))</span>
    <span class="n">snr_cont</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>                               
    <span class="n">snr_elines</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># I also need the continuum cubes</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">cont_mix_cube</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Very well, now, perform the continuum subtraction.</span>
        <span class="n">data</span> <span class="o">-=</span> <span class="n">cont_mix_cube</span>
    
    <span class="c1"># Get some info about the cube</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">start_row</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">end_row</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
	    <span class="n">end_row</span> <span class="o">=</span> <span class="n">nrows</span><span class="o">-</span><span class="mi">1</span> 
        
    <span class="n">fit_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">brutus_elf</span><span class="o">.</span><span class="n">els_mpfit</span><span class="p">,</span> <span class="n">lams</span><span class="o">=</span><span class="n">lams</span><span class="p">,</span> <span class="n">be</span><span class="o">=</span><span class="n">be</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
	<span class="c1"># Note here the clever use of the partial function, that turns the els_mpfit</span>
	<span class="c1"># function from something that takes 4 arguments into something that only takes 1</span>
	<span class="c1"># argument ... thus perfect for the upcoming &quot;map&quot; functions !</span>
    
    <span class="c1"># Very well, let&#39;s start the loop on rows. If the code crashes/is interrupted, you&#39;ll</span>
	<span class="c1"># loose the current row. Just live with it.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_row</span><span class="p">,</span><span class="n">end_row</span><span class="p">,</span> <span class="n">end_row</span><span class="o">-</span><span class="n">start_row</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>   
	    
		<span class="c1"># Alright, now deal with the spaxels outside the user-chosen SNR range.</span>
		<span class="c1"># Replace them with nan&#39;s</span>
        <span class="n">good_spaxels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines_snr_min&#39;</span><span class="p">]:</span>
             <span class="n">good_spaxels</span><span class="p">[</span><span class="n">snr_elines</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span><span class="o">&lt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines_snr_min&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines_snr_max&#39;</span><span class="p">]:</span>
             <span class="n">good_spaxels</span><span class="p">[</span><span class="n">snr_elines</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span><span class="o">&gt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines_snr_max&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
		
		<span class="c1"># Build a list of spectra to be fitted</span>
        <span class="n">specerrs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">]</span> <span class="o">*</span> <span class="n">good_spaxels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                     <span class="n">error</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">row</span><span class="p">]</span><span class="o">*</span> <span class="n">good_spaxels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">])]</span>
        
		<span class="c1"># Set up the multiprocessing pool of workers</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">]:</span>
            <span class="c1"># Did the user specify a number of processes to use ?</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>
                <span class="n">nproc</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">]</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span> <span class="o">=</span> <span class="n">nproc</span><span class="p">,</span> 
                                            <span class="n">initializer</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">init_worker</span><span class="p">())</span>
                
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Ok, just use them all ...</span>
                <span class="n">nproc</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                                            <span class="n">initializer</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">init_worker</span><span class="p">())</span>
			
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Fitting spectra in row %2.i, </span><span class="si">%i</span><span class="s1"> at a time ...&#39;</span> <span class="o">%</span> 
                                 <span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">nproc</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
			
			<span class="c1"># Launch the fitting ! Make sure to deal with KeyBoard Interrupt properly</span>
			<span class="c1"># Only a problem for multiprocessing. For the rest of the code, whatever.</span>
            <span class="k">try</span><span class="p">:</span>   
                <span class="n">els</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fit_func</span><span class="p">,</span> <span class="n">specerrs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39; interrupted !&#39;</span>
                <span class="c1"># Still close and join properly</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Multiprocessing line fitting interrupted at row </span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span> <span class="n">row</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># If all is fine</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  
              
        <span class="k">else</span><span class="p">:</span> <span class="c1"># just do things 1-by-1</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Fitting spectra in row %2.i, one at a time ...&#39;</span> <span class="o">%</span> 
                                 <span class="n">row</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span> 
                                
            <span class="n">els</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">fit_func</span><span class="p">,</span> <span class="n">specerrs</span><span class="p">)</span>
	    
	    <span class="c1"># Here, I need to save these results. Pickle could be fast and temporary,</span>
	    <span class="c1"># Until I then re-build the entire cube later on ? Also allow for better</span>
	    <span class="c1"># row-by-row flexibility.</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_row_&#39;</span><span class="o">+</span>
                          <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">els</span><span class="p">,</span><span class="nb">file</span><span class="p">)</span>
        <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
   	
   	<span class="c1"># Add the generic filename to the dictionary of filenames</span>
   	<span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_pickle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_row_&#39;</span>
   	     
    <span class="k">print</span> <span class="s1">&#39; done !&#39;</span>
    
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_make_elines_cube"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_make_elines_cube">[docs]</a><span class="k">def</span> <span class="nf">run_make_elines_cube</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to construct a &quot;usable and decent&quot; datacube out of the</span>
<span class="sd">    mess generated by the emission line fitting function, i.e. out of the many pickle </span>
<span class="sd">    files generated.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># First, load the original datacube. I need to know how much stuff was fitted.</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Build the wavelength array</span>
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    <span class="c1"># Calculate the outer bin edges for the spectrum</span>
    <span class="n">be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lams</span><span class="o">-</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">lams</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> 
    
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
       
    <span class="c1"># How many emission lines were fitted ?</span>
    <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> 
       
    <span class="c1"># Very well, what do I want to extract ?</span>
    <span class="c1"># 1) A &quot;full emission line spectrum&quot;</span>
    <span class="c1"># 2) For each line, a flux map, an intensity map, a velocity map and a dispersion map,</span>
    <span class="c1"># and h3 and h4 maps</span>
    <span class="c1"># Let&#39;s get to it.</span>
    <span class="n">elines_fullspec_cube</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># That way, I keep the nan&#39;s in the raw data</span>
    <span class="c1"># 7 params: Flux, I, v, sigma, h3, h4, SNR</span>
    <span class="n">elines_params_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="o">*</span><span class="n">nlines</span><span class="p">,</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># And the associated errors !</span>
    <span class="n">elines_params_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="o">*</span><span class="n">nlines</span><span class="p">,</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># Also save the status from mpfit. Could be useful for sorting the good from the bad.</span>
    <span class="n">elines_fit_status</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Constructing the datacube for the emission line fitting parameters.&#39;</span>
       
    <span class="c1"># Loop through the rows, and extract the results. </span>
    <span class="c1"># Try to loop through everything - in case this step was run in chunks.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nrows</span><span class="p">):</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">nrows</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Building cubes [</span><span class="si">%5.1f%s</span><span class="s1">]&#39;</span> <span class="o">%</span> 
                         <span class="p">(</span><span class="n">progress</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_pickle&#39;</span><span class="p">]</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="c1"># Very well, I have some fit here. Let&#39;s get them back</span>
            <span class="n">myfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">myfile</span><span class="p">)</span>  
            <span class="n">myfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
        
            <span class="c1"># Get all the parameters in a big array</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">params</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">perror</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">status</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
            
            <span class="c1"># Here, I need to make sure the ps and errs array have a decent shape, even </span>
            <span class="c1"># when the fit failed. Also store the STD that comes out of mpfit (NOT the variance!) </span>
            <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="k">else</span> <span class="n">ps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
                                                            <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ms</span><span class="p">)]</span>
            
            <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="k">else</span> 
                                                 <span class="n">errs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ms</span><span class="p">)]</span>
            
            
            <span class="c1"># Fill the corresponding datacube</span>
            <span class="c1"># First, what are my indices ? I need to keep one slice empty for the SNR of </span>
            <span class="c1"># each line. Get the indices where I will thus store the fit params.</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlines</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nlines</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span>
            
            <span class="n">elines_params_cube</span><span class="p">[</span><span class="n">ind</span><span class="p">,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">elines_params_err</span><span class="p">[</span><span class="n">ind</span><span class="p">,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">errs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">elines_fit_status</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            
            <span class="c1"># now, reconstruct the full emission line spectrum</span>
            <span class="n">elines_specs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">brutus_elf</span><span class="o">.</span><span class="n">els_spec</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">be</span><span class="o">=</span><span class="n">be</span><span class="p">,</span> 
                                                        <span class="n">method</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;line_profile&#39;</span><span class="p">],</span>
                                                        <span class="n">inst</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inst&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">])</span>
       
            <span class="c1"># Fill the corresponding cube </span>
            <span class="n">elines_fullspec_cube</span><span class="p">[:,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">elines_specs</span><span class="o">.</span><span class="n">T</span>
            
    
    <span class="c1"># Now, for each line, the first of these slices is the reference wavelength. </span>
    <span class="c1"># Replace this by the total flux instead ! And make some plots if requested.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        
        <span class="c1"># Calculate the sigma of the fit, in A (incl. instrument dispersion,etc ...)</span>
        <span class="c1"># as well as the associated error.</span>
        <span class="c1"># WARNING: unlike the data, these are the 1-sigma error coming out of mpfit.</span>
        <span class="c1"># Mind the **2 !</span>
        <span class="n">zlams</span> <span class="o">=</span> <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span> <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">c</span> <span class="p">)</span>
        <span class="n">zlams_err</span> <span class="o">=</span> <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">elines_params_err</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">c</span> <span class="c1"># The 1-std err</span>
        <span class="n">sigma_obs_A</span> <span class="o">=</span> <span class="n">brutus_elf</span><span class="o">.</span><span class="n">obs_sigma</span><span class="p">(</span><span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">],</span><span class="n">zlams</span><span class="p">,</span> 
                                          <span class="n">inst</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;inst&#39;</span><span class="p">],</span> 
                                          <span class="n">in_errs</span><span class="o">=</span><span class="p">[</span><span class="n">elines_params_err</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">],</span><span class="n">zlams_err</span><span class="p">]</span> <span class="p">)</span>
        
        <span class="c1"># Compute the line flux</span>
        <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:,:]</span> <span class="o">*</span> \
                                      <span class="n">sigma_obs_A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                           
        <span class="c1"># What about the error ?</span>
        <span class="n">elines_params_err</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="p">,:,:]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="p">,:,:])</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">elines_params_err</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                    <span class="n">sigma_obs_A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigma_obs_A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>           
    
    
    <span class="c1"># Now for each line, calculate the SNR</span>
    <span class="c1"># For this, I need the continuum cubes</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">cont_mix_cube</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cont_mix_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        
    <span class="c1"># Compute the residual cube</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">cont_mix_cube</span> <span class="o">-</span> <span class="n">elines_fullspec_cube</span>
    
    <span class="n">cont_range</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;cont_range&#39;</span><span class="p">]</span>
    <span class="n">lams0</span> <span class="o">=</span> <span class="n">lams</span> <span class="o">/</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Compute the noise over the region of interest defined by the user</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">residuals</span><span class="p">[(</span><span class="n">lams0</span><span class="o">&gt;=</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">lams0</span><span class="o">&lt;=</span><span class="n">cont_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),:,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
    
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">6</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">elines_params_cube</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">/</span><span class="n">noise</span>
       
    
    <span class="c1"># Export the cube for each emission line parameters as a multi-extension fits file        </span>
    <span class="c1"># Do the same for the errors - i.e. params and errors are in two distinct cubes</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">epc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">elines_params_cube</span><span class="p">,</span><span class="n">elines_params_err</span><span class="p">]):</span>
        <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    
        <span class="n">hdus</span> <span class="o">=</span> <span class="p">[</span><span class="n">hdu0</span><span class="p">]</span>
        <span class="c1"># Use the sorted keys, to ensure the same order as the fit parameters</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="n">hduk</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">epc</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="p">:</span><span class="mi">7</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">7</span><span class="p">,:,:])</span>
            <span class="c1"># Make sure the WCS coordinates are included as well</span>
            <span class="n">hduk</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hduk</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
            <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
            <span class="n">hduk</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hduk</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
            <span class="c1"># Add the line reference wavelength for future references</span>
            <span class="n">hduk</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_REFL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;reference wavelength&#39;</span><span class="p">)</span>
            <span class="n">hduk</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_CKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;F,I,v,sigma,h3,h4,SNR&#39;</span><span class="p">,</span><span class="s1">&#39;Content of the cube planes&#39;</span><span class="p">)</span>
            
            <span class="n">hdus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hduk</span><span class="p">)</span>
            
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="n">hdus</span><span class="p">)</span>
        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                              <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_&#39;</span><span class="o">+</span>
                              <span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="s1">&#39;perror&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.fits&#39;</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c1"># Add the filename to the dictionary of filenames</span>
        <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_&#39;</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="s1">&#39;perror&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span>\
                                                            <span class="s1">&#39;_elines_&#39;</span><span class="o">+</span>\
                                                            <span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="s1">&#39;perror&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.fits&#39;</span>
                   
    <span class="c1"># Very well, now let&#39;s also create a fits file to save the full emission line spectrum</span>
    <span class="c1"># as required.</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">elines_fullspec_cube</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_lams</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_fullspec.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_spec_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_fullspec.fits&#39;</span>
    
    <span class="c1"># And finally, the plot with the fit status for each spaxel, to know the bad from the </span>
    <span class="c1"># not-so-bad,</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">elines_fit_status</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_mpfit_status.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_fit_status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_mpfit_status.fits&#39;</span>
    
    <span class="k">print</span> <span class="s1">&#39; &#39;</span> 
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_plot_elines_cube"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_plot_elines_cube">[docs]</a><span class="k">def</span> <span class="nf">run_plot_elines_cube</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vrange</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                         <span class="n">sigrange</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39;Creates some plots for the emission lines: F, I, v and sigma.</span>
<span class="sd">        </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        vrange: list of int [default: None]</span>
<span class="sd">                If set, the range of the colorbar for the velocity plot.</span>
<span class="sd">        sigrangre: list of int [default: None]        </span>
<span class="sd">                If set, the range of the colorbar for the velocity dispersion plot.</span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames.</span>
<span class="sd">    &#39;&#39;&#39;</span>    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Making some nifty plots from the emission line fitting output.&#39;</span>
       
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
    
    <span class="c1"># Open the file</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>

    <span class="c1"># Create a temporary FITS file</span>
    <span class="n">fn_tmp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_tmp.fits&#39;</span><span class="p">)</span>

    <span class="c1"># Do this for each emission line fitted</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
    
        <span class="c1"># Because of the way aplpy works, I need to stored each &quot;image&quot; in its own fits</span>
        <span class="c1"># file. I don&#39;t want to keep them, so let&#39;s just use a temporary one, get the plot</span>
        <span class="c1"># done, and remove it. Not ideal, but who cares ?</span>
        
        <span class="n">this_header</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
        <span class="n">this_data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        
        <span class="c1"># Make single pretty plots for Flux, Intensity, velocity and velocity dispersion                                        </span>
        <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">typ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;v&#39;</span><span class="p">,</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span><span class="s1">&#39;h3&#39;</span><span class="p">,</span> <span class="s1">&#39;h4&#39;</span><span class="p">,</span> <span class="s1">&#39;SNR&#39;</span><span class="p">]):</span>
            
            <span class="c1"># Take into account the SNR from the user</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">!=</span> <span class="s1">&#39;SNR&#39;</span><span class="p">:</span>
                <span class="n">this_data</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">this_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
            <span class="c1"># Create a dedicated HDU    </span>
            <span class="n">tmphdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">this_data</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
            <span class="c1"># Add the WCS information</span>
            <span class="n">tmphdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">tmphdu</span><span class="p">,</span><span class="n">this_header</span><span class="p">)</span>
            <span class="n">tmphdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            
            <span class="c1"># Now plot it </span>
            <span class="n">this_ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span>
                                                        <span class="s1">&#39;_eline-&#39;</span><span class="o">+</span><span class="n">key</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span>
                                                        <span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;BR_REFL&#39;</span><span class="p">])</span><span class="o">+</span>
                                                        <span class="s1">&#39;_&#39;</span><span class="o">+</span>
                                                        <span class="n">typ</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">)</span> 
            
            <span class="c1"># For the velocity fields, set the vmin and vmax</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">my_vmin</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_vmax</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span>
                <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;arcsinh&#39;</span>
                <span class="n">my_label</span> <span class="o">=</span> <span class="s1">r&#39;F [10$^{-20}$ erg s$^{-1}$ cm$^{-2}$]&#39;</span>
                <span class="n">my_cbticks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">125</span><span class="p">,</span><span class="mi">250</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2000</span><span class="p">,</span><span class="mi">4000</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">my_vmin</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_vmax</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span>
                <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;arcsinh&#39;</span>
                <span class="n">my_label</span> <span class="o">=</span> <span class="s1">r&#39;I [10$^{-20}$ erg s$^{-1}$ cm$^{-2}$]&#39;</span>
                <span class="n">my_cbticks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">400</span><span class="p">,</span><span class="mi">800</span><span class="p">,</span><span class="mi">1600</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">vrange</span><span class="p">:</span>
                <span class="n">my_vmin</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">my_vmax</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">my_cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span>
                <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="n">my_label</span> <span class="o">=</span> <span class="s1">r&#39;$v$ [km s$^{-1}$]&#39;</span>
                <span class="n">my_cbticks</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="n">sigrange</span><span class="p">:</span>
                <span class="n">my_vmin</span> <span class="o">=</span> <span class="n">sigrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">my_vmax</span> <span class="o">=</span> <span class="n">sigrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">my_cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span>
                <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="n">my_label</span> <span class="o">=</span> <span class="s1">r&#39;$\sigma_{tot}$ [km s$^{-1}$]&#39;</span>
                <span class="n">my_cbticks</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">my_vmin</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_vmax</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_cmap</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">my_stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="n">my_label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">my_cbticks</span> <span class="o">=</span> <span class="bp">None</span>
                                                            
            <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ofn</span><span class="o">=</span><span class="n">this_ofn</span><span class="p">,</span> <span class="n">contours</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                                    <span class="n">vmin</span><span class="o">=</span><span class="n">my_vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">my_vmax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">my_cmap</span><span class="p">,</span>
                                    <span class="n">stretch</span> <span class="o">=</span> <span class="n">my_stretch</span><span class="p">,</span> <span class="n">cblabel</span><span class="o">=</span><span class="n">my_label</span><span class="p">,</span> 
                                    <span class="n">cbticks</span> <span class="o">=</span> <span class="n">my_cbticks</span><span class="p">,</span>
                                    <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],)</span>                                   
    
    <span class="c1"># Delete the temporary fits file</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">)</span>
    <span class="c1"># Don&#39;t forget to close the initial hdu ...</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># And also create a plot of the fit status, to see if anything weird happened</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_fit_status&#39;</span><span class="p">])</span>
    <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span>
                                                        <span class="s1">&#39;_eline_mpfit_status.pdf&#39;</span><span class="p">)</span> 
    <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ofn</span><span class="o">=</span><span class="n">ofn</span><span class="p">,</span> <span class="n">contours</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">16</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                           <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;alligator&#39;</span><span class="p">,</span><span class="n">stretch</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                           <span class="n">cbticks</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cblabel</span><span class="o">=</span><span class="s1">&#39;mpfit status&#39;</span><span class="p">,</span>
                           <span class="n">scalebar</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_inspect_fit"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_inspect_fit">[docs]</a><span class="k">def</span> <span class="nf">run_inspect_fit</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span><span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">irange</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">],</span> <span class="n">vrange</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]):</span>   
    <span class="sd">&#39;&#39;&#39;Setup the interactive inspection of the fit results.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        irange: list of int [default: [None,None]]</span>
<span class="sd">                The range of the colorbar for the intensity plot.</span>
<span class="sd">        vrange: list of int [default: [None,None]]    </span>
<span class="sd">                The range of the colorbar for the velocity dispersion plot.</span>

<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Starting the interactive inspection of the fitting.&#39;</span>
    
    <span class="c1"># Load the different files I need  </span>
    <span class="c1"># Raw data:    </span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    
    <span class="c1"># The Lowess continuum fit</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;lowess_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;lowess_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">lowess</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lowess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
    <span class="c1"># The ppxf continuum fit</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">ppxf</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ppxf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># The continuum mix datacube</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;cont_mix_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">cont_mix</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cont_mix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
       
    <span class="c1"># The elines fit</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_spec_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_spec_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">elines</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="n">elines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
    
    <span class="c1"># Also open the map and vmap to be displayed. </span>
    <span class="c1"># TODO: give user the choice of image on the right</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="nb">map</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vmap</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">vmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>    
    
    <span class="c1"># A filename if the user decides to save anything.</span>
    <span class="n">my_ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_fit_inspection_&#39;</span><span class="p">)</span>

    <span class="c1"># Launch the interactive plot</span>
    <span class="n">brutus_plots</span><span class="o">.</span><span class="n">inspect_spaxels</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">lowess</span><span class="p">,</span><span class="n">ppxf</span><span class="p">,</span><span class="n">cont_mix</span><span class="p">,</span> <span class="n">elines</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">vmap</span><span class="p">,</span> 
                                 <span class="n">irange</span><span class="p">,</span> <span class="n">vrange</span><span class="p">,</span>
                                 <span class="n">ofn</span> <span class="o">=</span> <span class="n">my_ofn</span><span class="p">)</span>    
        
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_find_structures"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_find_structures">[docs]</a><span class="k">def</span> <span class="nf">run_find_structures</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span><span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">interactive_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> 
                        <span class="n">automatic_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to identify structures (e.g. HII regions) in the data from</span>
<span class="sd">    a 2D image (i.e. an line intensity map), and save them to a pickle file. When</span>
<span class="sd">    interactive_mode=True, the user can manually refine the selection. Set</span>
<span class="sd">    automatic_mode=False to skip the automatic detection.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Starting the semi-automated procedure for structure identification.&#39;</span>
    
    <span class="c1"># Where am I going to save the apertures information ?</span>
    <span class="n">fn_ap</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_list.pkl&#39;</span><span class="p">)</span>
    
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ap_list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_list.pkl&#39;</span>
    
    <span class="c1"># Do we want to build apertures based on multiple maps ? Loop, one after the other.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ap_map_lines&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;   Loading eline </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">key</span> 
        <span class="c1"># Is the file already there ? Do I want to overwrite it ? And/or use its content ?</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn_ap</span><span class="p">):</span>
            <span class="k">print</span> <span class="s1">&#39;    &#39;</span>
            <span class="k">print</span> <span class="s1">&#39;   Existing aperture list (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">fn_ap</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">print</span> <span class="s1">&#39;   Type [a] to load this aperture list and edit it manually&#39;</span>
            <span class="k">print</span> <span class="s1">&#39;        [b] to start from scratch, (file will be overwritten!)&#39;</span>
            <span class="k">print</span> <span class="s1">&#39;        [c] to do nothing, and continue to the next step&#39;</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">letter</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
            
                <span class="k">if</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s1">&#39;        [</span><span class="si">%s</span><span class="s1">] unrecognized. Try again.&#39;</span> <span class="o">%</span> <span class="n">letter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">letter</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
            
        <span class="c1"># Open the file, load the list of apertures</span>
        <span class="k">if</span> <span class="n">letter</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn_ap</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">start_aps</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">letter</span> <span class="o">==</span><span class="s1">&#39;b&#39;</span><span class="p">:</span>
            <span class="n">start_aps</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">letter</span> <span class="o">==</span><span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
    
        <span class="c1"># Now, open the elines param datacube, and extract the Flux map I want to detect</span>
        <span class="c1"># stuctures from.</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">plane</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Launch the aperture finding routine</span>
        <span class="n">apertures</span> <span class="o">=</span> <span class="n">brutus_plots</span><span class="o">.</span><span class="n">build_ap_list</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start_aps</span> <span class="o">=</span> <span class="n">start_aps</span><span class="p">,</span> 
                                              <span class="n">radius</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ap_radius&#39;</span><span class="p">],</span>
                                              <span class="n">automatic_mode</span> <span class="o">=</span> <span class="n">automatic_mode</span><span class="p">,</span>
                                              <span class="n">interactive_mode</span> <span class="o">=</span> <span class="n">interactive_mode</span><span class="p">,</span>
                                              <span class="n">lam</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">save_plot</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                                                                       <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span>
                                                                       <span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span>
                                                                       <span class="s1">&#39;_ap_list_&#39;</span><span class="p">),</span>
                                             <span class="p">)</span>    
        
        <span class="c1"># Only if the user wants to save the apertures, do it</span>
        <span class="k">if</span> <span class="n">apertures</span><span class="p">:</span>
            <span class="c1"># Save the results for later use</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn_ap</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">apertures</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_make_ap_cube"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_make_ap_cube">[docs]</a><span class="k">def</span> <span class="nf">run_make_ap_cube</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to make a cube from a series of apertures (x,y,rs).</span>
<span class="sd">    For compativilty with spaxels-by-spaxels analysis codes (incl.brutus), make the cube</span>
<span class="sd">    the same size as the original, and repleace each spectra in a given aperture by the</span>
<span class="sd">    total aperture spectra. Spaxels outside any apertures are nan&#39;s. </span>
<span class="sd">    Assigned spaxels to one aperture only, in order of decreasing flux peak. This makes </span>
<span class="sd">    the data redondant, but will allow for a rapid and direct processing of the resulting</span>
<span class="sd">    cube by brutus.</span>
<span class="sd">    &#39;&#39;&#39;</span>        
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Constructing the cube with the integrated &#39;</span><span class="o">+</span>\
              <span class="s1">&#39;aperture spectra.&#39;</span>
    
    <span class="c1"># Very well, where is the aperture file ?</span>
    <span class="n">fn_ap</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ap_list&#39;</span><span class="p">])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn_ap</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">start_aps</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">,</span><span class="n">rs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">start_aps</span><span class="p">)</span>
    
    <span class="c1"># I will also need the Flux map from the strongest line - use that set for the </span>
    <span class="c1"># velocity reference of the line fitting</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;ref_dv_line&#39;</span><span class="p">]:</span>
            <span class="n">ref_key</span> <span class="o">=</span> <span class="n">key</span>
    
    <span class="c1"># Very well, now load the corresponding flux map</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">fheader0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ref_key</span><span class="p">)</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">plane</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fheader1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">plane</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># I also need to load the raw data cube. Here I ONLY use the raw cube - and NOT the</span>
    <span class="c1"># one possibly deredened for galactic extinction.</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Get all the peak intensities associated with each aperture. Needed for sorting them.</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="n">ys</span><span class="p">,</span><span class="n">xs</span><span class="p">]</span>
    
    <span class="c1"># Sort them in decreasing order of peak intensity</span>
    <span class="n">sort_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">fs</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Now, construct a map where each pixel contains the number of the region it belongs </span>
    <span class="c1"># to. Starting from 0.</span>
    <span class="n">ap_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="p">(</span><span class="n">ny</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="p">]</span>
    
    <span class="c1"># Also construct an aperture spectra cube</span>
    <span class="n">ap_spec_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">ap_spec_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># Loop through each ap. Hopefully not too slow ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sort_index</span><span class="p">):</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">sort_index</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Dealing with aperture </span><span class="si">%i</span><span class="s1"> [</span><span class="si">%5.1f%s</span><span class="s1">]&#39;</span> <span class="o">%</span> 
                         <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">progress</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="c1"># Find all spaxels with the ap radius </span>
        <span class="c1"># Don&#39;t do anything fancy, just measure the distance to each spaxel center.</span>
        <span class="n">in_ap</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c1"># Assign each spaxel (not yet assigned to another brighter feature) the </span>
        <span class="c1"># corresponding ap number.</span>
        <span class="n">ap_map</span><span class="p">[</span><span class="n">in_ap</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ap_map</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1">#For this aperture, sum all spaxels into master aperture spectra, and fill the </span>
        <span class="c1"># cube. Avoid the nans (e.g. mosaic edges, etc ...)</span>

        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">error</span><span class="p">[:,</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Loop through each spaxel in the aperture. There MUST be a smarter way, but I</span>
        <span class="c1"># can&#39;t figure it out. Should not be too costly time-wise anyway ...</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">])):</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ap_map</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="n">ap_spec_cube</span><span class="p">[:,</span><span class="n">yi</span><span class="p">,</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">ap_spec_err</span><span class="p">[:,</span><span class="n">yi</span><span class="p">,</span><span class="n">xi</span><span class="p">]</span>  <span class="o">=</span> <span class="n">err</span>
        
    <span class="c1"># All done. Save the aperture map to a fits file.</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">fheader0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">ap_map</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">fheader1</span><span class="p">)</span>
    <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_map.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>    
    
    <span class="c1"># Add this filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ap_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_map.fits&#39;</span>
    
    <span class="c1"># Make a plot of the apertures ?</span>
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
        <span class="n">this_ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_map.pdf&#39;</span><span class="p">)</span>
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ofn</span><span class="o">=</span><span class="n">this_ofn</span><span class="p">,</span> <span class="n">contours</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                                    <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;alligator&#39;</span><span class="p">,</span>
                                    <span class="n">stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                                    <span class="n">cblabel</span><span class="o">=</span><span class="s1">r&#39;Aperture idendification number&#39;</span><span class="p">,</span> 
                                    <span class="n">cbticks</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                    <span class="n">scalebar</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                <span class="p">)</span>  
    
    <span class="c1"># And also save the aperture spectral cube to a fits file</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">ap_spec_cube</span><span class="p">)</span>
    <span class="n">hdu2</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">ap_spec_err</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="p">[</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">]:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_lams</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
        
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_spec_cube.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>   
      
    <span class="c1"># Add this filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ap_spec_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ap_spec_cube.fits&#39;</span>
                                     
    <span class="k">print</span> <span class="s1">&#39; &#39;</span>
    
    <span class="k">return</span> <span class="n">fn_list</span>           </div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_extragal_dered"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_extragal_dered">[docs]</a><span class="k">def</span> <span class="nf">run_extragal_dered</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39;Corrects the line fluxes for the extragalactic reddening using Ha and Hb.</span>
<span class="sd">    </span>
<span class="sd">    This function returns a corrected set of line fluxes, as well as the associated Av </span>
<span class="sd">    map.</span>
<span class="sd">     </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        do_plot: bool [default: True]</span>
<span class="sd">                 Whether to make a plot of the Av map or not.</span>
<span class="sd">        </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">                 </span>
<span class="sd">    :Notes:</span>
<span class="sd">        Should I add some info about each curve here ? </span>
<span class="sd">    &#39;&#39;&#39;</span>  
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Correcting for the extragalactic attenuation.&#39;</span>
    
    <span class="c1"># Open the raw data cube</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS3&#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CD3_3&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>
    <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># Import the Halpha and Hbeta maps, and mask any spaxel not within the proper SNR range</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ha</span><span class="p">:</span>
            <span class="n">ha_map</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ha_map</span><span class="p">[</span><span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">hb</span><span class="p">:</span>
            <span class="n">hb_map</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hb_map</span><span class="p">[</span><span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


    <span class="n">hahb</span> <span class="o">=</span> <span class="n">ha_map</span> <span class="o">/</span> <span class="n">hb_map</span>
    <span class="c1"># Construct the Av map, just because I can</span>
    <span class="n">av</span> <span class="o">=</span> <span class="n">brutus_red</span><span class="o">.</span><span class="n">hahb_to_av</span><span class="p">(</span><span class="n">hahb</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;hahb_0&#39;</span><span class="p">],</span> <span class="n">curve</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_curve&#39;</span><span class="p">],</span> 
                              <span class="n">rv</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_rv&#39;</span><span class="p">],</span> <span class="n">rva</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_rva&#39;</span><span class="p">])</span>

    <span class="c1"># Now, for each emission line fitted, let&#39;s correct the flux:</span>
    <span class="c1"># A storage structure for the emission lines. Keep the un-reddened flux as well.</span>
    <span class="n">drelines_params_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="o">*</span><span class="n">nlines</span><span class="p">,</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">drelines_perror_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="o">*</span><span class="n">nlines</span><span class="p">,</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Load the current line parameters, loop through, and save to a new - bigger - array.</span>
    <span class="c1"># Also take care of the error</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
    <span class="n">fn_err</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_perror_cube&#39;</span><span class="p">])</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">hdu_err</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn_err</span><span class="p">)</span>
    <span class="n">fheader0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">fheader0_err</span> <span class="o">=</span> <span class="n">hdu_err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    
    <span class="c1"># Loop through each emission line</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="n">drelines_params_cube</span><span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">drelines_perror_cube</span><span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hdu_err</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># And add the de-reddened line flux in the first layer.</span>
        <span class="c1"># Note: the reddening correction is based on the de-redshifted line wavelength,</span>
        <span class="c1"># because this happens in the rest-frame of the target !</span>
        <span class="n">this_lam</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">drelines_params_cube</span><span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                                     <span class="n">brutus_red</span><span class="o">.</span><span class="n">extragalactic_red</span><span class="p">(</span><span class="n">this_lam</span><span class="p">,</span> <span class="n">hahb</span><span class="p">,</span> 
                                                                 <span class="n">params</span><span class="p">[</span><span class="s1">&#39;hahb_0&#39;</span><span class="p">],</span>
                                                                 <span class="n">curve</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_curve&#39;</span><span class="p">],</span> 
                                                                 <span class="n">rv</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_rv&#39;</span><span class="p">],</span>
                                                                 <span class="n">rva</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_rva&#39;</span><span class="p">])</span>
        <span class="c1"># Assume the reddening correction is error free ... sigh...</span>
        <span class="n">drelines_perror_cube</span><span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu_err</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                                     <span class="p">(</span><span class="n">brutus_red</span><span class="o">.</span><span class="n">extragalactic_red</span><span class="p">(</span><span class="n">this_lam</span><span class="p">,</span> <span class="n">hahb</span><span class="p">,</span> 
                                                                 <span class="n">params</span><span class="p">[</span><span class="s1">&#39;hahb_0&#39;</span><span class="p">],</span>
                                                                 <span class="n">curve</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_curve&#39;</span><span class="p">],</span> 
                                                                 <span class="n">rv</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_rv&#39;</span><span class="p">],</span>
                                                                 <span class="n">rva</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;egal_rva&#39;</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>                                                        
    <span class="n">fheader1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">fheader1_err</span> <span class="o">=</span> <span class="n">hdu_err</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">hdu_err</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    
    <span class="k">for</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">epc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">drelines_params_cube</span><span class="p">,</span> <span class="n">drelines_perror_cube</span><span class="p">]):</span>
        <span class="c1"># Ok, now save the data </span>
        <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">fheader0</span><span class="p">)</span>
    
        <span class="n">hdus</span> <span class="o">=</span> <span class="p">[</span><span class="n">hdu0</span><span class="p">]</span>
        <span class="c1"># Use the sorted keys, to ensure the same order as the fit parameters</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="n">hduk</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">epc</span><span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">k</span><span class="p">:</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),:,:])</span>
            <span class="c1"># Make sure the WCS coordinates are included as well</span>
            <span class="n">hduk</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hduk</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
            <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
            <span class="n">hduk</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hduk</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
            <span class="c1"># Add the line reference wavelength for future references</span>
            <span class="n">hduk</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_REFL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;reference wavelength&#39;</span><span class="p">)</span>
            <span class="n">hduk</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_CKEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dredF,F,I,v,sigma,h3,h4&#39;</span><span class="p">,</span><span class="s1">&#39;Content of the cube planes&#39;</span><span class="p">)</span>
            
            <span class="n">hdus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hduk</span><span class="p">)</span>
            
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="n">hdus</span><span class="p">)</span>
        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                              <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_elines_&#39;</span><span class="o">+</span>
                              <span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="s1">&#39;perror&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_dered.fits&#39;</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c1"># Add the filename to the dictionary of filenames</span>
        <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_&#39;</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="s1">&#39;perror&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span>\
                                                                  <span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span>\
                                                                  <span class="s1">&#39;_elines_&#39;</span><span class="o">+</span>\
                                                                  <span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="s1">&#39;perror&#39;</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="o">+</span>\
                                                                  <span class="s1">&#39;_dered.fits&#39;</span>
                   
    <span class="c1"># Very well, now let&#39;s also create a fits file to save the Av map</span>
    <span class="c1"># as required.</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">av</span><span class="p">)</span>
    <span class="c1"># Make sure the WCS coordinates are included as well</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
    <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_Av.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;Av_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_Av.fits&#39;</span>
    
    <span class="c1"># If requested, save a plot for the Av map.</span>
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
        
        <span class="n">this_ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_Av_map.pdf&#39;</span><span class="p">)</span>
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ofn</span><span class="o">=</span><span class="n">this_ofn</span><span class="p">,</span> <span class="n">contours</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                                    <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;alligator&#39;</span><span class="p">,</span>
                                    <span class="n">stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> 
                                    <span class="n">cblabel</span><span class="o">=</span><span class="s1">r&#39;A$_V$ [mag]&#39;</span><span class="p">,</span> 
                                    <span class="n">cbticks</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                    <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                                <span class="p">)</span>
                                    
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ---------------------------------------------------------------------------------------- </span>
  
<div class="viewcode-block" id="run_fit_kinematic_pa"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_fit_kinematic_pa">[docs]</a><span class="k">def</span> <span class="nf">run_fit_kinematic_pa</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> 
                         <span class="n">vrange</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">]):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function computes the kinematic position angle for the stars or the gas, </span>
<span class="sd">    via the fit_kinematic_pa() routine from M.Cappellari (not included with brutus). </span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        do_plot: bool [default: True]</span>
<span class="sd">                 Whether to make a plot of the kinematic map or not.</span>
<span class="sd">        vrange: list of int [default: [None,None]]    </span>
<span class="sd">                The range of the colorbar for the velocity plot.</span>
<span class="sd">                 </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">                 </span>
<span class="sd">    :Notes:</span>
<span class="sd">        pyqz is NOT included with brutus. A separate installation is required.</span>
<span class="sd">        See http://fpavogt.github.io/pyqz/installation.html</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Fitting the kinematic position angle.&#39;</span>
    
    <span class="n">all_kin_pas</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># How many kinematic maps do I want to fit ?</span>
    <span class="k">for</span> <span class="n">kin</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;fit_kin&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="k">print</span> <span class="s1">&#39;   [</span><span class="si">%s</span><span class="s1">] ...&#39;</span> <span class="o">%</span> <span class="n">kin</span>
            
        <span class="c1"># First, I need to load the kinematic maps and the associated errors</span>
        <span class="k">if</span> <span class="n">kin</span> <span class="o">==</span> <span class="s1">&#39;ppxf&#39;</span><span class="p">:</span> 
        
            <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ppxf_sol_map&#39;</span><span class="p">])</span> 
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">vel</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dvel</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># No error on the velocity coming from ppxf. Will be set to 10km/s </span>
                        <span class="c1"># by fit_kinematic_pa()</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
        <span class="k">elif</span> <span class="n">kin</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kin</span><span class="p">)</span>
            
            <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">vel</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vel</span><span class="p">[</span><span class="n">snr</span><span class="o">&lt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">kin</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Take into account the SNR</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
            <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_perror_cube&#39;</span><span class="p">])</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">dvel</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Correct for the redshift</span>
        <span class="n">vel</span> <span class="o">-=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span> <span class="c1"># Correct for the velocity</span>
                
        <span class="c1"># Very well, I now have my velocity map. How big is it ?</span>
        <span class="p">(</span><span class="n">ny</span><span class="p">,</span><span class="n">nx</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>
        
        <span class="c1"># Build the array of indices</span>
        <span class="n">ys</span><span class="p">,</span><span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Now, I need to recenter this based on the kinematical center for the object</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;fit_kin_center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;fit_kin_center&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Handle the presence of NaNs ...</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">vel</span><span class="o">==</span><span class="n">vel</span><span class="p">]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">vel</span><span class="o">==</span><span class="n">vel</span><span class="p">]</span>
        <span class="n">vel_nonan</span> <span class="o">=</span> <span class="n">vel</span><span class="p">[</span><span class="n">vel</span><span class="o">==</span><span class="n">vel</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">dvel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">dvel</span> <span class="o">=</span> <span class="n">dvel</span><span class="p">[</span><span class="n">vel</span><span class="o">==</span><span class="n">vel</span><span class="p">]</span>
    
        <span class="c1"># Reschape all of it ...    </span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
        <span class="n">vel_nonan</span> <span class="o">=</span> <span class="n">vel_nonan</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">vel_nonan</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">dvel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">dvel</span> <span class="o">=</span> <span class="n">dvel</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dvel</span><span class="p">))</span>
            
        <span class="c1"># Very well, let&#39;s launch the processing</span>
        <span class="n">all_kin_pas</span><span class="p">[</span><span class="n">kin</span><span class="p">]</span> <span class="o">=</span> <span class="n">fkp</span><span class="o">.</span><span class="n">fit_kinematic_pa</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">vel_nonan</span><span class="p">,</span> <span class="n">dvel</span> <span class="o">=</span> <span class="n">dvel</span><span class="p">,</span>
                                                <span class="n">debug</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> 
                                                <span class="n">nsteps</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;fit_kin_nsteps&#39;</span><span class="p">],</span> 
                                                <span class="n">plot</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
    
        <span class="c1"># Ok, what do I want to do with this ? A plot, and save it for later ?</span>
        <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
            
            <span class="c1"># Create a temporary FITS file</span>
            <span class="n">fn_tmp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_tmp.fits&#39;</span><span class="p">)</span>
            
            <span class="c1"># Let&#39;s create a temporary fits file with the given velocity map  </span>
            <span class="n">tmphdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">vel</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;z_target&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
            <span class="c1"># Add the WCS information</span>
            <span class="n">tmphdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">tmphdu</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
            <span class="n">tmphdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            
        
            <span class="c1"># Alright, let&#39;s make a velocity plot.</span>
            <span class="k">if</span> <span class="n">kin</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">ofn</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_fit_kinematic_pa_</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> \
                                                              <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">kin</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ofn</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_fit_kinematic_pa_</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="n">kin</span>
            
            <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span> <span class="n">ofn</span><span class="p">)</span>
            
            <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dvelplot</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">,</span> <span class="c1"># path to the data (complete!)</span>
                                        <span class="n">ext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># Which extension am I looking for ?</span>
                                        <span class="n">ofn</span> <span class="o">=</span> <span class="n">ofn</span><span class="p">,</span> <span class="c1"># Savefig filename</span>
                                        <span class="n">contours</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="c1"># Draw any contours </span>
                                        <span class="n">stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                        <span class="n">vmin</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                        <span class="n">vmax</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span><span class="p">,</span>
                                        <span class="n">cblabel</span> <span class="o">=</span> <span class="s1">r&#39;v [km s$^{-1}$]&#39;</span><span class="p">,</span>
                                        <span class="n">cbticks</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                        <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                                        <span class="n">pa</span> <span class="o">=</span> <span class="n">all_kin_pas</span><span class="p">[</span><span class="n">kin</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span> 
                                        <span class="n">center</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;fit_kin_center&#39;</span><span class="p">],</span>
                                        <span class="p">)</span>
            <span class="c1"># Clean up the temporary file</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fn_tmp</span><span class="p">)</span>
            
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;fit_kin_pa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_fit_kinematic_pa.pkl&#39;</span>
    
    <span class="c1"># And save these avlues in a pickle file, for future access if needed.</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;fit_kin_pa&#39;</span><span class="p">]),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">all_kin_pas</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ---------------------------------------------------------------------------------------- </span>
  
<div class="viewcode-block" id="run_get_ne"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_get_ne">[docs]</a><span class="k">def</span> <span class="nf">run_get_ne</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">ratio_range</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function computes the kinematic position angle for the stars or the gas, </span>
<span class="sd">    via the fit_kinematic_pa() routine from M.Cappellari (not included with brutus). </span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        do_plot: bool [default: True]</span>
<span class="sd">                Whether to make a plot of the electron density map or not.</span>
<span class="sd">        ratio_range: list [default[None,None]</span>
<span class="sd">                The line ratio range, for the plot.</span>
<span class="sd">                 </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">                 </span>
<span class="sd">    :Notes:</span>
<span class="sd">        pyqz is NOT included with brutus. A separate installation is required.</span>
<span class="sd">        See http://fpavogt.github.io/pyqz/installation.html</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Constructing the [SII] line ratio.&#39;</span>
    
    
    <span class="c1"># Alright, let&#39;s load the emission line fluxes</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;pyqz_use_egal_dered&#39;</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_params&#39;</span><span class="p">])</span>
        <span class="n">fn_e</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_perror&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
        <span class="n">fn_e</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_perror_cube&#39;</span><span class="p">])</span>

    
    <span class="n">s2h_key</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span>
    
    <span class="c1"># Open the files</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>

    <span class="n">hdu_e</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn_e</span><span class="p">)</span>
    <span class="n">header0_e</span> <span class="o">=</span> <span class="n">hdu_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    
    
    <span class="c1"># Now loop through these, until I find the lines I need</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2h</span><span class="p">:</span>
            <span class="n">header_s2h</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">s2h_map</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">s2h_err</span> <span class="o">=</span> <span class="n">hdu_e</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2l</span><span class="p">:</span>
            <span class="n">header_s2l</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
            <span class="n">s2l_map</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">s2l_err</span> <span class="o">=</span> <span class="n">hdu_e</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Very well, let&#39;s compute the ratio map and error:</span>
    <span class="n">ratio_map</span> <span class="o">=</span> <span class="n">s2h_map</span><span class="o">/</span><span class="n">s2l_map</span>
    <span class="n">ratio_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ratio_map</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">s2h_err</span><span class="o">/</span><span class="n">s2h_map</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">s2l_err</span><span class="o">/</span><span class="n">s2l_map</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Let&#39;s export this to a dedicated fits file.</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">ratio_map</span><span class="p">)</span>
    <span class="n">hdu2</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">ratio_err</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="p">[</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">]:</span>
        <span class="c1"># Make sure the WCS coordinates are included as well</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">header_s2h</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
    
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">,</span><span class="n">hdu2</span><span class="p">])</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_[SII]-ratio.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;ne_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_[SII]-ratio.fits&#39;</span>
    
    <span class="c1"># And now, let&#39;s plot it.</span>
    <span class="k">if</span> <span class="n">do_plot</span><span class="p">:</span>
         
            <span class="n">ofn</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_[SII]-ratio.pdf&#39;</span>
            
            <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span> <span class="n">ofn</span><span class="p">)</span>
            
            <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="c1"># path to the data (complete!)</span>
                                        <span class="n">ext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1"># Which extension am I looking for ?</span>
                                        <span class="n">ofn</span> <span class="o">=</span> <span class="n">ofn</span><span class="p">,</span> <span class="c1"># Savefig filename</span>
                                        <span class="n">contours</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="c1"># Draw any contours </span>
                                        <span class="n">stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                        <span class="n">vmin</span> <span class="o">=</span> <span class="n">ratio_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                        <span class="n">vmax</span> <span class="o">=</span> <span class="n">ratio_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span><span class="p">,</span>
                                        <span class="n">cblabel</span> <span class="o">=</span> <span class="s1">r&#39;[S\,\textsc{\smaller{II}}] $\lambda$6731 / [S\,\textsc{\smaller{II}}] $\lambda$6716 &#39;</span><span class="p">,</span>
                                        <span class="n">cbticks</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                        <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                                        <span class="p">)</span> 
        
    
    <span class="k">return</span> <span class="n">fn_list</span></div>

<span class="c1"># ---------------------------------------------------------------------------------------- </span>
  
<div class="viewcode-block" id="run_get_QZ"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_get_QZ">[docs]</a><span class="k">def</span> <span class="nf">run_get_QZ</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end_row</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function computes the ionization parameter and oxygen abundance of HII regions</span>
<span class="sd">    using the pyqz module: http://fpavogt.github.io/pyqz/ </span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        start_row: int [default: 0]</span>
<span class="sd">                   The starting row from which to process the data</span>
<span class="sd">        end_row: int [default: None]</span>
<span class="sd">                 The row at which to finish the processing. Set to None for the max row.</span>
<span class="sd">                 </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">                 </span>
<span class="sd">    :Notes:</span>
<span class="sd">        pyqz is NOT included with brutus. A separate installation is required.</span>
<span class="sd">        See http://fpavogt.github.io/pyqz/installation.html</span>
<span class="sd">    &#39;&#39;&#39;</span>       
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Deriving Log(Q) and Tot(O)+12 using pyqz.&#39;</span>
    
    <span class="c1"># Very well, now I need to open the line fluxes.</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;pyqz_use_egal_dered&#39;</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_params&#39;</span><span class="p">])</span>
        <span class="n">fn_e</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_perror&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>
        <span class="n">fn_e</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_perror_cube&#39;</span><span class="p">])</span>

    <span class="c1"># Alright, now I need to extract the line fluxes and errors</span>
    <span class="c1"># Open the files</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>

    <span class="n">hdu_e</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn_e</span><span class="p">)</span>
    <span class="n">header0_e</span> <span class="o">=</span> <span class="n">hdu_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>

    <span class="c1"># All elines definition are inside elines_pyqz inside brutus_metadata. </span>
    <span class="c1"># For each of them, construct a flux map.</span>

    <span class="n">elines_fluxes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">elines_errors</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Look at each emission line fitted. If it is part of a &quot;pyqz emission line</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">akey</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
    
        <span class="n">this_header</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
        <span class="n">this_data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">this_error</span> <span class="o">=</span> <span class="n">hdu_e</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                               
        <span class="n">lam</span> <span class="o">=</span> <span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;BR_REFL&#39;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elines_pyqz</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c1"># Search all possible known pyqz lines</span>
            <span class="k">if</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">elines_pyqz</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span> <span class="c1"># Wavelength match ? I found a line.</span>
            
                <span class="n">flux</span> <span class="o">=</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">this_error</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="c1"># Take into account the SNR</span>
                <span class="n">flux</span><span class="p">[</span><span class="n">this_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">akey</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
                <span class="c1"># Already exists ? - then I found a line with multiple components</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elines_fluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                    <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="c1"># append the flux</span>
                    <span class="n">elines_errors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">flux</span><span class="p">]</span> <span class="c1"># Save the data for later</span>
                    <span class="n">elines_errors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">err</span><span class="p">]</span>
                       
    <span class="c1"># Close the hdus</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">hdu_e</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                    
    <span class="c1"># Alright, I extracted all my lines fluxes. Am I missing anything ? </span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">elines_fluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elines_pyqz</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;ERROR: a line component is missing for </span><span class="si">%s</span><span class="s1">. Was it fitted ?&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="c1"># Now, proceed to construct the dictionary of line fluxes and errors.</span>
    <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">nx</span> <span class="o">=</span> <span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>

    <span class="c1"># Get some info about the cube</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">start_row</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">start_row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">end_row</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
	    <span class="n">end_row</span> <span class="o">=</span> <span class="n">nrows</span><span class="o">-</span><span class="mi">1</span> 
    
    <span class="c1"># Very well, let&#39;s start the loop on rows. If the code crashes/is interrupted, you&#39;ll</span>
	<span class="c1"># loose the current row. Just live with it.</span>
	<span class="c1"># Here, multiprocessing is already implemented inside the pyqz module. No need to do</span>
	<span class="c1"># anything else but feed pyqz.get_global_qz() big chunks in a for loop.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_row</span><span class="p">,</span> <span class="n">end_row</span><span class="p">,</span> <span class="n">end_row</span><span class="o">-</span><span class="n">start_row</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>       
	    
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>    
                <span class="n">nproc</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;multiprocessing&#39;</span><span class="p">]</span>
                
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Ok, just use them all ...</span>
                <span class="n">nproc</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># Limit this to 8 for brutus - memory issues ...</span>
        <span class="k">if</span> <span class="n">nproc</span><span class="o">&gt;</span><span class="mi">8</span><span class="p">:</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">8</span>    
	        
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Dealing with spectra in row %2.i, </span><span class="si">%i</span><span class="s1"> at a time ...&#39;</span> <span class="o">%</span> 
                         <span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">nproc</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span> 
        
        <span class="c1"># The structure to hold the list of line fluxes, for each row</span>
        <span class="n">allmylines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span><span class="n">nlines</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">allmynames</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Very well, let&#39;s start filling a big array with all my lines fluxes lined up </span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

             <span class="c1"># Very well, sum it all</span>
            <span class="n">fluxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">item</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">elines_errors</span><span class="p">[</span><span class="n">key</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># CHECK THAT THIS DOES WHAT I THINK IT DOES ! </span>
            <span class="c1"># pyqz requires errors as 1-std. Like the output of mpfit.</span>
            <span class="c1"># Also get rid of the nan&#39;s in the errors ... because pyqz can&#39;t deal with them.</span>
            <span class="n">errors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">errors</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">allmylines</span><span class="p">[:,</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">fluxes</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
            <span class="n">allmylines</span><span class="p">[:,</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[:,</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    
            <span class="n">allmynames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">allmynames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>
    
        <span class="c1"># I need to keep track of which spaxel went where, so I can make sense of the files</span>
        <span class="c1"># generated by pyqz. </span>
        <span class="n">spaxel_ids</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">-</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)]</span>    
    
        <span class="c1"># Ready to go - let&#39;s launch pyqz</span>
        <span class="n">pyqz_out</span> <span class="o">=</span> <span class="n">pyqz</span><span class="o">.</span><span class="n">get_global_qz</span><span class="p">(</span><span class="n">allmylines</span><span class="p">,</span> <span class="n">allmynames</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;pyqz_diags&#39;</span><span class="p">],</span> 
                                      <span class="n">ids</span> <span class="o">=</span> <span class="n">spaxel_ids</span><span class="p">,</span> 
                                      <span class="n">qzs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LogQ&#39;</span><span class="p">,</span> <span class="s1">&#39;Tot[O]+12&#39;</span><span class="p">],</span>
                                      <span class="n">Pk</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">struct</span><span class="o">=</span><span class="s1">&#39;pp&#39;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                      <span class="n">error_pdf</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span><span class="p">,</span> 
                                      <span class="n">srs</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">flag_level</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>  <span class="n">KDE_method</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">,</span> 
                                      <span class="n">KDE_qz_sampling</span> <span class="o">=</span> <span class="mi">101j</span><span class="p">,</span> <span class="n">KDE_do_singles</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> 
                                      <span class="n">KDE_pickle_loc</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;pyqz_loc&#39;</span><span class="p">],</span> 
                                      <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span><span class="p">)</span>    
 
	    <span class="c1"># Here, I need to save these results. Pickle could be fast and temporary,</span>
	    <span class="c1"># Until I then re-build the entire cube later on ? Also allow for better</span>
	    <span class="c1"># row-by-row flexibility.</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_pyqz_row_&#39;</span><span class="o">+</span>
                          <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">pyqz_out</span><span class="p">,</span><span class="nb">file</span><span class="p">)</span>
        <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
   	
   	<span class="c1"># Add the generic filename to the dictionary of filenames</span>
   	<span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;pyqz_pickle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_pyqz_row_&#39;</span>
   	     
    <span class="k">print</span> <span class="s1">&#39; done !&#39;</span>
    
    <span class="k">return</span> <span class="n">fn_list</span></div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_make_QZ_cube"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_make_QZ_cube">[docs]</a><span class="k">def</span> <span class="nf">run_make_QZ_cube</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">do_plot</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to construct a &quot;usable and decent&quot; datacube out of the</span>
<span class="sd">    mess generated by the pyqz step.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        do_plot: bool [default: True]</span>
<span class="sd">                 Whether to make some nifty plots or not.</span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">    &#39;&#39;&#39;</span> 
    
    <span class="c1"># First, load the original datacube. I need to know how much stuff was fitted.</span>
    <span class="k">if</span> <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_loc&#39;</span><span class="p">],</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;data_fn&#39;</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;galdered_cube&#39;</span><span class="p">]))</span>
        
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="n">header2</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
    
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span>
       
    <span class="c1"># Very well, what do I want to extract ?</span>
    <span class="c1"># A 2-D map for all the variable returned by pyqz. STore this in a multi-extension fits</span>
    
    <span class="c1"># Open one of these files, to check how much variables I want to map</span>
    <span class="n">fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span><span class="s1">&#39;*pyqz*.pkl&#39;</span><span class="p">))</span>
    
    <span class="n">ftmp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ftmp</span><span class="p">)</span>
    <span class="n">ftmp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="n">map_names</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># All the different variable names.</span>
   
    <span class="n">all_maps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">map_names</span><span class="p">),</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">],</span><span class="n">header1</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Constructing the datacube for the pyqz output.&#39;</span>
       
    <span class="c1"># Loop through the rows, and extract the results. </span>
    <span class="c1"># Try to loop through everything - in case this step was run in chunks.</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nrows</span><span class="p">):</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="mf">100.</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="n">nrows</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">   Building cube [</span><span class="si">%5.1f%s</span><span class="s1">]&#39;</span> <span class="o">%</span> 
                         <span class="p">(</span><span class="n">progress</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;tmp_loc&#39;</span><span class="p">],</span>
                          <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;pyqz_pickle&#39;</span><span class="p">]</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">row</span><span class="p">))</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="c1"># Very well, I have some fit here. Let&#39;s get them back</span>
            <span class="n">myfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ms</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">myfile</span><span class="p">)</span>  
            <span class="n">myfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> 
        
            <span class="c1"># Ok, one line to store it all back !</span>
            <span class="n">all_maps</span><span class="p">[:,:,</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># Get ready with the extension file</span>
    <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">header0</span><span class="p">)</span>
    
    <span class="n">hdus</span> <span class="o">=</span> <span class="p">[</span><span class="n">hdu0</span><span class="p">]</span>
    <span class="c1"># Store each map in a dedicated HDU</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_names</span><span class="p">):</span>
        <span class="n">hduk</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">all_maps</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:])</span>
        <span class="c1"># Make sure the WCS coordinates are included as well</span>
        <span class="n">hduk</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hduk</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hduk</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hduk</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
        <span class="c1"># Add the line reference wavelength for future references</span>
        <span class="n">hduk</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_PYQZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;pyqz variable&#39;</span><span class="p">)</span>
            
        <span class="n">hdus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hduk</span><span class="p">)</span>
            
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="n">hdus</span><span class="p">)</span>
    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span> 
                          <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_pyqz_QZs.fits&#39;</span><span class="p">)</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
    <span class="c1"># Add the filename to the dictionary of filenames</span>
    <span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;pyqz_QZs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_pyqz_QZs.fits&#39;</span>
    
    <span class="k">print</span> <span class="s1">&#39; &#39;</span>
    
    <span class="c1"># Make some plots, if requested:</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="nb">map</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_names</span><span class="p">):</span>
        
        
        <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_pyqz_&#39;</span><span class="o">+</span>
                         <span class="nb">map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">,</span><span class="s1">&#39;_vs_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.pdf&#39;</span><span class="p">)</span>
        
        <span class="n">mymap</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span><span class="s1">&#39;$&lt;$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span><span class="s1">&#39;$&gt;$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;{&#39;</span><span class="p">,</span><span class="s1">&#39;$\{$&#39;</span><span class="p">)</span>
        <span class="n">mymap</span> <span class="o">=</span> <span class="n">mymap</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">,</span><span class="s1">&#39;$\}$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Log&#39;</span><span class="p">,</span><span class="s1">&#39;$\log$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span><span class="s1">&#39;  &#39;</span><span class="p">)</span>
        <span class="n">mymap</span> <span class="o">=</span> <span class="n">mymap</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;\_&#39;</span><span class="p">)</span>
        <span class="n">mylabel</span> <span class="o">=</span> <span class="s1">r&#39;&#39;</span> <span class="o">+</span> <span class="n">mymap</span>
        
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="c1"># path to the data (complete!)</span>
                    <span class="n">ext</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># Which extension am I looking for ?</span>
                    <span class="n">ofn</span> <span class="o">=</span> <span class="n">ofn</span><span class="p">,</span> <span class="c1"># Savefig filename</span>
                    <span class="n">contours</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="c1"># Draw any contours </span>
                    <span class="n">stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                    <span class="n">vmin</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> 
                    <span class="n">vmax</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;alligator&#39;</span><span class="p">,</span>
                    <span class="n">cblabel</span> <span class="o">=</span> <span class="n">mylabel</span><span class="p">,</span>
                    <span class="n">cbticks</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                    <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fn_list</span>    </div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_plot_elines_RGB"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_plot_elines_RGB">[docs]</a><span class="k">def</span> <span class="nf">run_plot_elines_RGB</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                        <span class="n">mixes</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;[NII]&#39;</span><span class="p">,</span><span class="s1">&#39;Ha&#39;</span><span class="p">,</span><span class="s1">&#39;[OIII]&#39;</span><span class="p">],],</span> 
                        <span class="n">stretches</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">,],</span>
                        <span class="n">stretch_plims</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">10.</span><span class="p">,</span><span class="mf">99.5</span><span class="p">,</span><span class="mf">10.</span><span class="p">,</span><span class="mf">99.5</span><span class="p">,</span><span class="mf">10.</span><span class="p">,</span><span class="mf">99.5</span><span class="p">],],</span>
                        <span class="n">stretch_vlims</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">],],</span>
                        <span class="n">use_egal_dered</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                       <span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to make some RGB images from emission lines.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        mixes: list of list [default: [[&#39;[NII]&#39;,&#39;Ha&#39;,&#39;[OIII]&#39;]]]</span>
<span class="sd">             A list of line triplets indicatin the R, G &amp; B channels.</span>
<span class="sd">        stretches: list of string [default: [&#39;log&#39;]]</span>
<span class="sd">                   The stretches to apply to the data, e.g. &#39;linear&#39;, &#39;log&#39;, &#39;arcsinh&#39;.</span>
<span class="sd">        stretch_plims: list of list of floats [default: [[10.,99.5,10.,99.5,10.,99.5],]]</span>
<span class="sd">                       The limiting percentiles for the plot, as </span>
<span class="sd">                       [pmin_r, pmax_r, pmin_g, pmax_g, pmin_b, pmax_b]</span>
<span class="sd">        stretch_vlims: list of list of floats [default: [[10.,99.5,10.,99.5,10.,99.5],]]</span>
<span class="sd">                       The limtiing values for the plot (superseeds stretch_plims), as</span>
<span class="sd">                       [vmin_r, vmax_r, vmin_g, vmax_g, vmin_b, vmax_b]</span>
<span class="sd">        use_egal_dered: bool [default: False]</span>
<span class="sd">                        If available, whether to use the line fluxes corrected for </span>
<span class="sd">                        extragalactic attentuation.</span>
<span class="sd">             </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">    &#39;&#39;&#39;</span> 
    
    <span class="c1"># First, I need to generate 3 individual fits files with the line fluxes</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Creating some RGB emission line images.&#39;</span>
    
    <span class="c1"># Very well, now I need to open the line fluxes.</span>
    <span class="k">if</span> <span class="n">use_egal_dered</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_params&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>

    <span class="c1"># Alright, now I need to extract the line fluxes</span>
    <span class="c1"># Open the file</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>

    <span class="c1"># All elines definition are inside elines_pyqz inside brutus_metadata. </span>
    <span class="c1"># For the ones the user requested, construct a flux map.</span>
    <span class="n">elines_fluxes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mix</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mixes</span><span class="p">):</span>
        <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="bp">None</span><span class="p">}</span>    

    <span class="c1"># Look at each emission line fitted. Do I need it ?</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">akey</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
    
        <span class="n">this_header</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
        <span class="n">this_data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                               
        <span class="n">lam</span> <span class="o">=</span> <span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;BR_REFL&#39;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">mix</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mixes</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mix</span><span class="p">):</span> <span class="c1"># Search all possible lines</span>
                <span class="k">if</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">elines_pyqz</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span> <span class="c1"># Wavelength match ? I found a line.</span>
            
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
                    <span class="c1"># Take into account the SNR</span>
                    <span class="n">flux</span><span class="p">[</span><span class="n">this_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">akey</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
                    <span class="c1"># Already exists ? - then I found a line with multiple components</span>
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span> 
                        <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">flux</span> <span class="c1"># append the flux</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux</span> <span class="c1"># Save the data for later</span>
                       
    <span class="c1"># Close the hdus</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Very well, I now have all my line fluxes. Let&#39;s deal with each RGB set one at a time.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">mix</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mixes</span><span class="p">):</span>

        <span class="n">fns</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                 <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_RGB_</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">mix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">mix</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                 
        <span class="c1"># Now, let&#39; create 3 independant temporary fits file with WCS coordinates</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mix</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span><span class="s1">&#39;RGB_tmp_</span><span class="si">%i</span><span class="s1">.fits&#39;</span> <span class="o">%</span> <span class="n">cc</span><span class="p">)</span>
            <span class="n">fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">],</span> <span class="n">header</span> <span class="o">=</span> <span class="n">header1</span><span class="p">)</span>
            <span class="c1"># Add the wcs info</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">header1</span><span class="p">)</span>
            <span class="n">outfits</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">hdu</span><span class="p">])</span>
            <span class="n">outfits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
        <span class="c1"># Great, I am now ready to call the plotting function</span>
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_RGBplot</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">ofn</span><span class="p">,</span>  <span class="n">stretch</span> <span class="o">=</span> <span class="n">stretches</span><span class="p">[</span><span class="n">m</span><span class="p">],</span>
                                  <span class="n">plims</span> <span class="o">=</span> <span class="n">stretch_plims</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">vlims</span> <span class="o">=</span> <span class="n">stretch_vlims</span><span class="p">[</span><span class="n">m</span><span class="p">],</span>
                                  <span class="n">title</span> <span class="o">=</span> <span class="s1">r&#39;RGB: </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>  <span class="p">(</span><span class="n">mix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">mix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">mix</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                                  <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">])</span>
    
        <span class="c1"># And remember to delete all the temporary files</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>    
    
    <span class="k">return</span> <span class="n">fn_list</span>    </div>
<span class="c1"># ----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="run_plot_flux_ratio"><a class="viewcode-back" href="../modules/brutus.html#brutus.run_plot_flux_ratio">[docs]</a><span class="k">def</span> <span class="nf">run_plot_flux_ratio</span><span class="p">(</span><span class="n">fn_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                        <span class="n">ratios</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;[NII]/[OIII]&#39;</span><span class="p">,],</span>
                        <span class="n">vrange</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">],],</span>
                        <span class="n">use_egal_dered</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                       <span class="p">):</span>   
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    This function is designed to make some images from emission lines flux ratios.</span>
<span class="sd">    </span>
<span class="sd">    :Args:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The dictionary containing all filenames created by brutus.</span>
<span class="sd">        params: dictionary</span>
<span class="sd">                The dictionary containing all paramaters set by the user. </span>
<span class="sd">        suffix: string [default: None]</span>
<span class="sd">                The tag of this step, to be used in all files generated for rapid id.</span>
<span class="sd">        ratios: list of string [default: [&#39;[NII]/[OIII]&#39;]]</span>
<span class="sd">             A list of line ratios to plot.</span>
<span class="sd">        vrange: list of lists [default: [[Mone,None]]]</span>
<span class="sd">                The plot range.</span>
<span class="sd">        use_egal_dered: bool [default: False]</span>
<span class="sd">                        If available, whether to use the line fluxes corrected for </span>
<span class="sd">                        extragalactic attentuation.</span>
<span class="sd">             </span>
<span class="sd">    :Returns:</span>
<span class="sd">        fn_list: dictionary</span>
<span class="sd">                 The updated dictionary of filenames. </span>
<span class="sd">    &#39;&#39;&#39;</span> 
    
       <span class="c1"># First, I need to generate 3 individual fits files with the line fluxes</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
        <span class="k">print</span> <span class="s1">&#39;-&gt; Creating some line ratio images.&#39;</span>
    
    <span class="c1"># Very well, now I need to open the line fluxes.</span>
    <span class="k">if</span> <span class="n">use_egal_dered</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;dered_elines_params&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span><span class="n">fn_list</span><span class="p">[</span><span class="s1">&#39;elines_params_cube&#39;</span><span class="p">])</span>

    <span class="c1"># Alright, now I need to extract the line fluxes</span>
    <span class="c1"># Open the file</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">header0</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="n">header1</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>

    <span class="c1"># All elines definition are inside elines_pyqz inside brutus_metadata. </span>
    <span class="c1"># For the ones the user requested, construct a flux map.</span>
    <span class="n">elines_fluxes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mix</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ratios</span><span class="p">):</span>
        <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="bp">None</span><span class="p">}</span>    

    <span class="c1"># Look at each emission line fitted. Do I need it ?</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">akey</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
    
        <span class="n">this_header</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
        <span class="n">this_data</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                               
        <span class="n">lam</span> <span class="o">=</span> <span class="n">this_header</span><span class="p">[</span><span class="s1">&#39;BR_REFL&#39;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">mix</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ratios</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)):</span> <span class="c1"># Search all possible lines</span>
                <span class="k">if</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">elines_pyqz</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span> <span class="c1"># Wavelength match ? I found a line.</span>
            
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
                    <span class="c1"># Take into account the SNR</span>
                    <span class="n">flux</span><span class="p">[</span><span class="n">this_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;elines&#39;</span><span class="p">][</span><span class="n">akey</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
                    <span class="c1"># Already exists ? - then I found a line with multiple components</span>
                    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span> 
                        <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">flux</span> <span class="c1"># append the flux</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux</span> <span class="c1"># Save the data for later</span>
                       
    <span class="c1"># Close the hdus</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Very well, I now have all my line fluxes. Let&#39;s deal with each set one at a time.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">mix</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ratios</span><span class="p">):</span>
        
        <span class="n">ofn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;plot_loc&#39;</span><span class="p">],</span>
                 <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ratio_</span><span class="si">%s</span><span class="s1">_vs_</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                                                      <span class="n">mix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span>
                 
        <span class="c1"># Now, let&#39; create a fits file with WCS coordinates</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;prod_loc&#39;</span><span class="p">],</span>
                 <span class="n">suffix</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;_ratio_</span><span class="si">%s</span><span class="s1">_vs_</span><span class="si">%s</span><span class="s1">.fits&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                                                       <span class="n">mix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span>
            
        <span class="n">hdu0</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span> <span class="o">=</span> <span class="n">header0</span><span class="p">)</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">elines_fluxes</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Make sure the WCS coordinates are included as well</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_wcs</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">header1</span><span class="p">)</span>
        <span class="c1"># Also include a brief mention about which version of brutus is being used</span>
        <span class="n">hdu1</span> <span class="o">=</span> <span class="n">brutus_tools</span><span class="o">.</span><span class="n">hdu_add_brutus</span><span class="p">(</span><span class="n">hdu1</span><span class="p">,</span><span class="n">suffix</span><span class="p">)</span>
        <span class="c1"># Add the line reference wavelength for future references</span>
        <span class="n">hdu1</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;BR_RATIO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mix</span><span class="p">,</span> <span class="s1">&#39;line ratio&#39;</span><span class="p">)</span>
            
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span><span class="n">hdus</span><span class="o">=</span><span class="p">[</span><span class="n">hdu0</span><span class="p">,</span><span class="n">hdu1</span><span class="p">])</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="c1"># Great, I am now ready to call the plotting function</span>
        <span class="n">brutus_plots</span><span class="o">.</span><span class="n">make_2Dplot</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ofn</span> <span class="o">=</span> <span class="n">ofn</span><span class="p">,</span> <span class="n">contours</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> 
                                 <span class="n">stretch</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                 <span class="n">vmin</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                                 <span class="n">vmax</span> <span class="o">=</span> <span class="n">vrange</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">cmap</span> <span class="o">=</span> <span class="n">alligator</span><span class="p">,</span>
                                 <span class="n">cblabel</span> <span class="o">=</span> <span class="s1">r&#39;$\log$ </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">mix</span><span class="p">,</span>
                                 <span class="n">cbticks</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                 <span class="n">scalebar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;scalebar&#39;</span><span class="p">],</span>
                                <span class="p">)</span>
                                
    
    <span class="k">return</span> <span class="n">fn_list</span>  </div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Frdric P.A. Vogt.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.3.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>